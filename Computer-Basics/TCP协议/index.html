<!-- build time:Tue Oct 31 2023 21:50:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="计算机基础"><link rel="canonical" href="https://1234cas.github.io/1234cas.github.io/Computer-Basics/TCP%E5%8D%8F%E8%AE%AE/"><title>TCP协议 - 计算机基础 | Sparkle = Sparkle = 加油</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">TCP协议</h1><div class="meta"><span class="item" title="创建时间：2023-05-15 10:40:05"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-15T10:40:05+08:00">2023-05-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.2k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sparkle</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 计算机基础"><span itemprop="name">计算机基础</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1234cas.github.io/1234cas.github.io/Computer-Basics/TCP%E5%8D%8F%E8%AE%AE/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sparkle"><meta itemprop="description" content="加油, 好好读书"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sparkle"></span><div class="body md" itemprop="articleBody"><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/cc9bc77b97b06659f29baec794f80ef2.png" alt="cc9bc77b97b06659f29baec794f80ef2"></p><h3 id="01tcp-和-udp-的区别"><a class="anchor" href="#01tcp-和-udp-的区别">#</a> 01.TCP 和 UDP 的区别？</h3><p><strong>TCP 是一个面向连接的，可靠的，基于字节流的传输层协议</strong></p><p><strong>UDP 是一个面向无连接的传输层协议</strong></p><p>和 UDP 相比，TCP 有三大核心特征：</p><p>1.<strong> 面向连接</strong>。在客户端和服务端互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程</p><p>2.<strong> 可靠性</strong>。可靠性体现在两方面，一是<strong>有状态</strong>，二是<strong>可控制</strong></p><p>TCP 会精确记录哪些数据发送了，哪些数据被对面接收了，哪些数据未被对面接收，并且保证数据包按序到达。这是<strong>有状态</strong></p><p>当意识到丢包或者网络环境不佳时，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是<strong>可控制</strong></p><p>3.<strong> 基于字节流</strong>。UDP 的数据传输是基于数据报的，这是因为仅仅只继承了 IP 层的特性，而 TCP 为了维护状态，把一个一个 IP 变成了字节流</p><hr><h3 id="02tcp-三次握手的过程-为什么不是两次不是四次"><a class="anchor" href="#02tcp-三次握手的过程-为什么不是两次不是四次">#</a> 02.TCP 三次握手的过程。为什么不是两次？不是四次</h3><p>TCP 的三次握手是为了确认双方的发送和接收能力</p><h4 id="三次握手"><a class="anchor" href="#三次握手">#</a> 三次握手</h4><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/d666610353017ffe36cf8eb3e2c24939.png" alt="d666610353017ffe36cf8eb3e2c24939"></p><p>从最开始双方都处于 <code>CLOSED</code> 状态，然后服务端开始监听某个端口，进入了 <code>LISTEN</code> 状态</p><p>然后客户端主动发起连接，发送 <code>SYN</code> ，自己变成了 <code>SYN-SEND</code> 状态</p><p>服务端接收到，并返回 <code>SYN</code> 和 <code>ACK</code> ，自己变成了 <code>SYN-RCVD</code> 状态</p><p>之后客户端再发送 <code>ACK</code> 给服务端，自己变成了 <code>ESTABLISHED</code> 状态；服务端收到 <code>ACK</code> 之后，也变成了 <code>ESTABLISHED</code> 状态</p><p>SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加 1</p><blockquote><p>凡是需要对端确认的，一定会消耗 TCP 报文的序列号</p></blockquote><p>SYN 需要对端确认，而 ACK 不需要，因此 SYN 消耗一个序列号而 ACK 不需要</p><h4 id="为什么不是两次"><a class="anchor" href="#为什么不是两次">#</a> 为什么不是两次？</h4><p>根本原因：无法确认客户端的接收能力</p><p>如果是两次，客户端发送了 SYN 报文想握手，但是这个包<strong>滞留</strong>在了网络中，TCP 以为是丢包，于是重传，然后两次握手就建立了连接。</p><p>看似没有问题，但是连接关闭后，如果这个<strong>滞留</strong>在网络中的包到达了服务端，由于是两次握手，服务端接收到<strong>滞留</strong>的包同时发送相应的数据包就建立了连接，可是这时客户端是不会响应的，但是服务端会一直等待客户端发送数据，导致了服务端连接资源的浪费</p><h4 id="为什么不是四次"><a class="anchor" href="#为什么不是四次">#</a> 为什么不是四次？</h4><p>TCP 的三次握手是为了确认双方的发送和接收能力，四次自然也是可以，但是三次就足够了</p><h4 id="三次握手过程中可以携带数据么"><a class="anchor" href="#三次握手过程中可以携带数据么">#</a> 三次握手过程中可以携带数据么？</h4><p>第三次握手时可以携带，前两次握手不能携带数据</p><p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放入大量的数据，那么服务器就势必会消耗更多的时间和内存空间去处理这些数据，增加了服务器被攻击的风险</p><p>第三次握手的时候，客户端已经处于 <code>ESTABLISHED</code> 状态，并且已经确认了服务器的接收发送能力，这时相对安全，可以携带数据</p><h4 id="同时发起握手会怎样"><a class="anchor" href="#同时发起握手会怎样">#</a> 同时发起握手会怎样</h4><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/57f1cc50167613e9ce02641095b56dbe.png" alt="57f1cc50167613e9ce02641095b56dbe"></p><p>客户端和服务端同时给对面发送 <code>SYN</code> ，发完两者的状态皆变为 <code>SYN-SENT</code></p><p>在各自收到对方的 <code>SYN</code> 之后，两者的状态都变成 <code>SYN-RCVD</code></p><p>接着会回复对应的 <code>SYN+ACK</code> ，这个报文在对方接收之后会一起变成 <code>ESTABLISHED</code></p><hr><h3 id="03四次挥手的过程"><a class="anchor" href="#03四次挥手的过程">#</a> 03. 四次挥手的过程</h3><h4 id="四次挥手"><a class="anchor" href="#四次挥手">#</a> 四次挥手</h4><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/982a7c427e18571f51b529e70c2a961b.png" alt="982a7c427e18571f51b529e70c2a961b"></p><p>刚开始双方都处于 <code>ESTABLISHED</code></p><p>客户端要断开，向服务端发送 <code>FIN</code> 报文，然后客户端变成了 <code>FIN-WAIT-1</code> 状态，注意，客户端同时也变成 <code>half-close(半关闭)</code> 状态，即无法向服务端发送报文，只能接收</p><p>服务端接收后向客户端发送 <code>ACK</code> 确认，变成了 <code>CLOSE-WAIT</code> 状态</p><p>客户端接收到了客户端的确认，变成了 <code>FIN-WAIT2</code> 状态</p><p>随后服务端向客户端发送 <code>FIN</code> ，自己进入 <code>LAST-ACK</code> 状态</p><p>客户端收到服务端的 <code>FIN</code> 后，自己变成 <code>TIME-WAIT</code> 状态，然后向服务端发送 <code>ACK</code></p><p>此时客户端需要等待足够长的时间，具体来说，还是 2 个 <code>MSL(Maximum Segment Lifetime,报文最大生存时间)</code> ，在这段时间如果客户端没有收到服务端的重发请求，那么就表示 <code>ACK</code> 成功送达，挥手介绍，否则客户端重发 <code>ACK</code></p><h4 id="等待-2msl-的意义"><a class="anchor" href="#等待-2msl-的意义">#</a> 等待 2MSL 的意义</h4><p>如果不等待会怎样？</p><p>如果不等待，客户端直接断开连接，当服务端还有很多数据包要发给客户端，且还在路上的时候，若客户端的端口此时刚好被新的应用，那么就接收到了无用数据包，导致数据包混乱，所以，最保险的做法是等服务端发完的数据包再启动新的应用</p><ul><li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文能最终送达对端</li><li>1 个 MSL 确保对端没有收到 ACK 而重传的 FIN 报文可以到达</li></ul><h4 id="为什么是四次挥手而不是三次"><a class="anchor" href="#为什么是四次挥手而不是三次">#</a> 为什么是四次挥手而不是三次？</h4><p>因为服务端在收到 <code>FIN</code> 时，往往不会立即反回 <code>FIN</code> ，必须等服务端此前所有的报文都发送完毕了，才能发 <code>FIN</code> 。因此先发一个 <code>ACK</code> 表示已经收到客户端的 <code>FIN</code> ，延长一段再发 <code>FIN</code> 。</p><p>如果是三次挥手会有什么问题？</p><p>等于说服务端把 <code>ACK</code> 和 <code>FIN</code> 的发送合并为一次挥手，这会造成长时间的延迟，导致客户端误以为 <code>FIN</code> 没有到达服务端，从而不断重发 <code>FIN</code></p><h4 id="同时关闭会怎样"><a class="anchor" href="#同时关闭会怎样">#</a> 同时关闭会怎样？</h4><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/19ebe3ed769f299bd212544892b97a0f.png" alt="19ebe3ed769f299bd212544892b97a0f"></p><hr><h3 id="04半连接队列和-syn-flood-攻击的关系"><a class="anchor" href="#04半连接队列和-syn-flood-攻击的关系">#</a> 04. 半连接队列和 SYN Flood 攻击的关系</h3><p>三次握手前，服务端的状态从 <code>CLOSED</code> 变成 <code>LISTEN</code> ，同时在内部创建了两个队列：<strong>半连接队列</strong>和<strong>全连接队列</strong>，即 <code>SYN</code> 队列和 <code>ACCEPT</code> 队列</p><h4 id="半连接队列"><a class="anchor" href="#半连接队列">#</a> 半连接队列</h4><p>当客户端发送 <code>SYN</code> 到服务端，服务端收到后回复 <code>ACK</code> 和 <code>SYN</code> ，状态由 <code>LISTEN</code> 变为 <code>SYN-RCVD</code> ，此时这个连接就会被推入<strong> SYN 队列</strong>，也就是<strong>半连接队列</strong></p><h4 id="全连接队列"><a class="anchor" href="#全连接队列">#</a> 全连接队列</h4><p>当客户端返回 <code>ACK</code> ，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走前，它会被推入另一个 TCP 维护的队列，也就是<strong>全连接队列 (Accept Queue)</strong></p><h4 id="syn-flood-攻击原理"><a class="anchor" href="#syn-flood-攻击原理">#</a> SYN Flood 攻击原理</h4><p>SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击原理就是用客户端再短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送 <code>SYN</code> 。对于服务端而言，会产生两个威胁的后果：</p><ol><li>处理大量的 <code>SYN</code> 包并返回对应的 <code>ACK</code> ，势必有大量的连接处于 <code>SYN-RCVD</code> 状态，从而占满整个<strong>半连接队列</strong>，无法处理正常的请求</li><li>由于是不存在的 IP，服务端长时间收不到客户端的 <code>ACK</code> ，会导致服务端不断重发数据，直到耗尽服务端的资源</li></ol><h4 id="如何应对-syn-flood-攻击"><a class="anchor" href="#如何应对-syn-flood-攻击">#</a> 如何应对 SYN Flood 攻击？</h4><ol><li>增加 SYN 连接，也就是增加半连接队列的容量</li><li>减少 SYN+ACK 重试次数，避免大量的超时重发</li><li>利用 SYN Cookie 技术，在服务端收到 <code>SYN</code> 后不立即分配连接资源，而是根据这个 <code>SYN</code> 计算出一个 <code>Cookie</code> ，连同第二次握手一起回复给客户端，在客户端回复 <code>ACK</code> 的时候带上这个 <code>Cookie</code> 值，服务端验证 <code>Cookie</code> 的合法性之后才会分配资源</li></ol><hr><h3 id="05tcp-报文的头部字段"><a class="anchor" href="#05tcp-报文的头部字段">#</a> 05.TCP 报文的头部字段</h3><p>报文头部结构如下 (单位为字节)：</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/9309f3c439fac129c56b298d7ab7f992.png" alt="9309f3c439fac129c56b298d7ab7f992"></p><h4 id="源端口-目标端口"><a class="anchor" href="#源端口-目标端口">#</a> 源端口、目标端口</h4><p>如果标识唯一的一个连接？答案是 TCP 连接的 <code>四元组</code> —— 源 IP、源端口、目标 IP、目标端口</p><p>那 TCP 报文为什么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP。TCP 只需要记录两者的端口即可</p><h4 id="序列号"><a class="anchor" href="#序列号">#</a> 序列号</h4><p>即 <code>Sequence number</code> ，指的是本报文第一个字节的序列号</p><p>从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到 0</p><p>序列号在 TCP 通信的过程中有两个作用：</p><ol><li>在 SYN 报文中交换彼此的初始序列号</li><li>保证数据包按正确的顺序组装</li></ol><h4 id="isn初始序列号"><a class="anchor" href="#isn初始序列号">#</a> ISN (初始序列号)</h4><p>即 <code>Initial Sequence Number(初始序列号)</code> ，在三次握手的过程当中，双方会用 <code>SYN</code> 报文来交换彼此的 <code>ISN</code></p><p><code>ISN</code> 并不是一个固定的值，而是每 4ms 加一，溢出则回到 0，这个算法使得猜测 <code>ISN</code> 变得很困难。为什么这么做呢？</p><p>如果 <code>ISN</code> 被攻击者预测到，要知道 IP 和源端口号都是很容易伪造的，当攻击者猜测到 <code>ISN</code> 之后，直接伪造一个 <code>RST</code> 后，就可以强制关闭连接，这是非常危险的</p><p>而动态增长的 <code>ISN</code> 大大提高了猜测 <code>ISN</code> 的难度</p><h4 id="确认号"><a class="anchor" href="#确认号">#</a> 确认号</h4><p>即 <code>ACK(Acknowlegment number)</code> 。用于告诉对方下一个期望接收的序列号，小于<strong> ACK</strong> 的所有字节都已经收到</p><h4 id="标记号"><a class="anchor" href="#标记号">#</a> 标记号</h4><p>常见的标记有 <code>SYN</code> , <code>ACK</code> , <code>FIN</code> , <code>RST</code> , <code>PSH</code></p><p><code>SYN</code> 和 <code>ACK</code> 已经在上文中说过，后三个解释如下:</p><p><code>FIN</code> ： 即 Finish，表示发送方准备断开连接。</p><p><code>RST</code> ：即 Reset，用来强制断开连接。</p><p><code>PSH</code> ： 即 Push，告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p><h4 id="窗口大小"><a class="anchor" href="#窗口大小">#</a> 窗口大小</h4><p>占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0~14，比例因子可以将窗口的值扩大为原来的 2^n 次方</p><h4 id="校验和"><a class="anchor" href="#校验和">#</a> 校验和</h4><p>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃，等待重传</p><h4 id="可选项"><a class="anchor" href="#可选项">#</a> 可选项</h4><p>可选项格式如下</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/417e77f83b34540a5b170e5b898b08f8.png" alt="417e77f83b34540a5b170e5b898b08f8"></p><p>常用的可选项有以下几个：</p><ul><li>TimeStamp:TCP 时间戳，后文有详细介绍</li><li>MSS: 指的是 TCP 允许对方接收的最大报文段</li><li>SACK: 选择确认选项</li><li>Window Scale: 窗口缩放选项</li></ul><hr><h3 id="06tcp-快速打开的原理tfo"><a class="anchor" href="#06tcp-快速打开的原理tfo">#</a> 06.TCP 快速打开的原理 (TFO)</h3><p>优化后的 TCP 握手流程，也就是 TCP 快速打开 (TCP Fast Open，即 TFO)</p><p>优化是利用 SYN Cookie 来实现的 TFO</p><h4 id="tfo-流程"><a class="anchor" href="#tfo-流程">#</a> TFO 流程</h4><p><strong>首轮三次握手</strong></p><p>首先客户端发送 <code>SYN</code> 给服务端，服务端收到</p><p>此时，服务端不是立即返回 <code>SYN+ACK</code> ，而是通过计算得到一个 <code>SYN Cookie</code> ，将这个 <code>Cookie</code> 放到 TCP 报文的 <code>Fast Open</code> 选项中，然后返回给客户端</p><p>客户端拿到这个 <code>Cookie</code> 的值并缓存下来。后面正常完成三次握手</p><p><strong>后续的三次握手</strong></p><p>在后续的三次握手中，客户端会将之前缓存的 <code>Cookie</code> 、 <code>SYN</code> 和 <code>HTTP请求</code> 发送给服务端，服务端验证了 <code>Cookie</code> 的合法性，如果不合法直接丢弃；如果合法，就正常返回 <code>SYN+ACK</code></p><p>重点来了，现在服务端就可以向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没有建立，仅仅验证了 <code>Cookie</code> 的合法性就可以返回 HTTP 响应</p><p>当然，客户端的 <code>ACK</code> 还得正常传过来，不然怎么叫三次握手</p><p>流程如下：</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/0ff20d5a9e4295e773c1380a82954afd.png" alt="0ff20d5a9e4295e773c1380a82954afd"></p><p><strong>注意</strong>：客户端最后握手的 <code>ACK</code> 不需要等到服务端的 HTTP 响应送达才发送，两者没有任何关系</p><h4 id="tfo-的优势"><a class="anchor" href="#tfo-的优势">#</a> TFO 的优势</h4><p>TFO 的优势并不在首轮三次握手，而在于后面的握手，在拿到客户端的 <code>Cookie</code> 并验证通过以后，可以直接返回 HTTP 响应，充分利用了<strong> 1 个 RTT</strong> (Round-Trip Time，往返时延) 的时间<strong>提前进行数据传输</strong>，积累起来还是一个比较大的优势</p><hr><h3 id="07tcp-报文中的时间戳"><a class="anchor" href="#07tcp-报文中的时间戳">#</a> 07.TCP 报文中的时间戳</h3><p><code>timestamp</code> 是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下：</p><pre><code class="language-HTTP">kind(1 字节) + length(1 字节) + info(8 个字节)
</code></pre><p>其中 kind = 8，length = 10，info 有两部分构成：<strong>timestamp</strong> 和<strong> timestamp echo</strong>，各占 4 个字节</p><p>TCP 的时间戳主要解决两大问题：</p><ul><li>计算 往返时延 RTT (Round-Trip Time)</li><li>防止序列号的回绕问题</li></ul><h4 id="计算-往返时延-rtt"><a class="anchor" href="#计算-往返时延-rtt">#</a> 计算 往返时延 RTT</h4><p>在没有时间戳的时候，计算 RTT 会遇到如下图所示的问题</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/d3d95220996ad83cbafd120a31a84d30.png" alt="d3d95220996ad83cbafd120a31a84d30"></p><p>如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大</p><p>如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小</p><p>实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的</p><p>这个时候引入时间戳就很好的解决了这个问题</p><p>比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 <code>ACK</code> 的报文 s2，那么：</p><ul><li><p>**step1：**a 向 b 发送的时候， <code>timestamp</code> 中存放的内容就是 a 主机发送时的内核时刻 <code>ta1</code></p></li><li><p>**step2：**b 向 a 回复 s2 报文时， <code>timestamp</code> 中存放的是 b 主机的时刻 <code>tb</code> ， <code>timestamp echo</code> 字段为从 s1 报文中解析出来的 <code>ta1</code></p></li><li><p>**step3：**a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 <code>ta2</code> ，而在 s2 报文中的 <code>timestamp echo</code> 选项可以得到 <code>ta1</code> ，也就是 s2 对应的报文最初的发送时刻。然后直接用 <code>ta2</code> - <code>ta1</code> 就得到了 RTT 的值</p></li></ul><h4 id="防止序列号的回绕问题"><a class="anchor" href="#防止序列号的回绕问题">#</a> 防止序列号的回绕问题</h4><p>现在我们来模拟一下这个问题。</p><p>序列号的范围其实是在 0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。</p><table><thead><tr><th>第几次发包</th><th>发送字节</th><th>对应序列号</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>0 ~ 1</td><td>0 ~ 1</td><td>成功接收</td></tr><tr><td>2</td><td>1 ~ 2</td><td>1 ~ 2</td><td>滞留在网络中</td></tr><tr><td>3</td><td>2 ~ 3</td><td>2 ~ 3</td><td>成功接收</td></tr><tr><td>4</td><td>3 ~ 4</td><td>3 ~ 4</td><td>成功接收</td></tr><tr><td>5</td><td>4 ~ 5</td><td>0 ~ 1</td><td>成功接收，序列号从 0 开始</td></tr><tr><td>6</td><td>5 ~ 6</td><td>1 ~ 2</td><td>？？？</td></tr></tbody></table><p>假设在第 6 次的时候，之前滞留在网络中的包送达了，那么就会有两个序列号为 <code>1 ~ 2</code> 的数据包，无法区分，这时候就产生了序列号的回绕问题</p><p>那么用 <code>timestamp</code> 就能很好的解决这个问题，因为每次发包的时候都会将发包机器当时的内核时间记录在报文中，即使两次发包的序列号相同，时间戳也不可能相同，这样子就可以区分开两个数据包了</p><hr><h3 id="08tcp-的超时重连"><a class="anchor" href="#08tcp-的超时重连">#</a> 08.TCP 的超时重连</h3><p>TCP 具有超时重连的机制，即每个一段时间没有等到数据包的回复时，就重传这个数据包</p><p>这个重传间隔是如何来计算的呢？</p><p>这个重传间隔也叫做<strong>超时重传时间 (Retransmission TimeOut，简称为 RTO)</strong>，它的计算跟上一节的<strong> RTT</strong> 密切相关。这我们将介绍两种重要的方法，一个是经典方法，一个是标准方法</p><h4 id="经典方法"><a class="anchor" href="#经典方法">#</a> 经典方法</h4><p>经典方法引入了一个新的概念 ——<strong>SRTT (Smoothed Round Trip Time，即平滑往返时间)</strong>，每产生一次新的 RTT，就会根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下 (SRTT 的初始值为 0)</p><pre><code class="language-HTTP">SRTT =  (α * SRTT) + ((1 - α) * RTT)
</code></pre><p>其中，α 是<strong>平滑因子</strong>，建议值是 <code>0.8</code> ，范围是 <code>0.8 ~ 0.9</code></p><p>拿到 SRTT，我们就可以计算 RTO 的值了：</p><pre><code class="language-HTTP">RTO = min(ubound, max(lbound, β * SRTT))
</code></pre><p>β 是加权因子，一般为 <code>1.3 ~ 2.0</code> ， <strong>lbound</strong> 是下界，<strong>ubound</strong> 是上界。</p><p>这个算法的过程还算是简单，但是也存在着一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是 <code>0.8 ~ 0.9</code> ，RTT 对于 RTO 的影响太小</p><h4 id="标准方法"><a class="anchor" href="#标准方法">#</a> 标准方法</h4><p>为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫 <code>Jacobson / Karels 算法</code></p><p>一共三步</p><p>** 第一步：** 计算 <code>SRTT</code> ，公式如下：</p><pre><code class="language-HTTP">SRTT = (1 - α) * SRTT + α * RTT
</code></pre><p>注意这个时候的 <code>α</code> 就和经典方法中的 <code>α</code> 取值不同了，建议值是 <code>1/8</code> ，也就是 <code>0.125</code></p><p>** 第二步：** 计算 <code>RTTVAR</code> （Round-Trip Time Variation）这个中间变量</p><pre><code class="language-HTTP">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
</code></pre><p>β 的建议值为 <code>0.25</code> 。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手</p><p>** 第三步：** 计算最终的 <code>RTO</code></p><pre><code class="language-HTTP">RTO = µ * SRTT + ∂ * RTTVAR
</code></pre><p><code>µ</code> 建议值取 <code>1</code> ， <code>∂</code> 建议值取 <code>4</code></p><p>这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切</p><hr><h3 id="09tcp-的流量控制"><a class="anchor" href="#09tcp-的流量控制">#</a> 09.TCP 的流量控制</h3><p>对于发送端和接收端而言，TCP 需要把发送的数据放到<strong>发送缓存区</strong>，将接收的数据放到<strong>接收缓存区</strong></p><p>而流量控制所要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能在继续发送了</p><p>要具体理解流量控制，首先需要了解 <code>滑动窗口</code> 的概念</p><h4 id="滑动窗口"><a class="anchor" href="#滑动窗口">#</a> 滑动窗口</h4><p>TCP 滑动窗口分为两种：<strong>发送窗口</strong>和<strong>接收窗口</strong></p><h4 id="发送窗口"><a class="anchor" href="#发送窗口">#</a> 发送窗口</h4><p>发送端的滑动窗口结构如下</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/4e618cbb8649a1617fc5594f40a23632.png" alt="4e618cbb8649a1617fc5594f40a23632"></p><p>其中包含四大部分：</p><ul><li>已发送且已接收</li><li>已发送但未确认</li><li>未发送但可发送</li><li>未发送且不可发送</li></ul><p>其中有一些重要的概念，我标注在图中：</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/364c7d48f0d1e503a7de1af5879b47e2-16353120181391.png" alt="364c7d48f0d1e503a7de1af5879b47e2"></p><p>发送窗口就是图中被框住的范围。SND 即 <code>send</code> ，WND 即 <code>window</code> ，UNA 即 <code>unacknowledged</code> ，表示未被确认，NXT 即 <code>next</code> ，表示下一个发送的位置</p><h4 id="接收窗口"><a class="anchor" href="#接收窗口">#</a> 接收窗口</h4><p>接收端的窗口结构如下：</p><p><img data-src="/images/TCP%E5%8D%8F%E8%AE%AE.assets/06c5ca9fe18976392fce8f158bb75249.png" alt="06c5ca9fe18976392fce8f158bb75249"></p><p>REV 即 <code>receive</code> ，NXT 表示下一个接收的位置，WND 表示接收窗口大小。</p><h4 id="流量控制过程"><a class="anchor" href="#流量控制过程">#</a> 流量控制过程</h4><p>这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家的理解</p><p>首先双方三次握手，初始化各自的窗口大小，均为 200 个字节</p><p>假如当前发送端给接收端发送 100 个字节，那么此时对应发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解</p><p>现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节即被应用取走 40 个字节，剩下 <code>60</code> 个字节被留在了缓冲队列中</p><p>注意了，此时接收端的情况是处理能力不足，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成 140 个字节，因为缓冲队列还有 60 个字节没被应用拿走 (还差多少就减少多少)</p><p>因此，接收端会在 ACK 的报文头部带上缩小后的滑动窗口 140 字节，发送端对应的调整发送窗口的大小为 140 字节</p><p>此时对应发送端而言，已发送且已接收的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时<strong>发送窗口</strong>缩小为 140 个字节</p><p>这就是<strong>流量控制</strong>的过程。尽管回合再多，整个控制的过程和原理是一样的</p><hr><h3 id="10tcp-的拥塞控制"><a class="anchor" href="#10tcp-的拥塞控制">#</a> 10.TCP 的拥塞控制</h3><p>上一节所说的<strong>流量控制</strong>发送在发送端和接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是 <code>拥塞控制</code> 需要处理的问题</p><p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态：</p><ul><li>拥塞窗口 (Congestion Window ，cwnd)</li><li>慢启动阈值 (Slow Start Threshold，ssthresh)</li></ul><p>涉及的算法有这几个：</p><ul><li>慢启动</li><li>拥塞避免</li><li>快速重传和快速恢复</li></ul><p>接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起</p><h4 id="拥塞窗口"><a class="anchor" href="#拥塞窗口">#</a> 拥塞窗口</h4><p>拥塞窗口 (Congestion Window ，cwnd) 是指目前自己还能传输的数据量大小</p><p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p><ul><li>接收窗口 (rwnd) 是 <code>接收端</code> 给的限制</li><li>拥塞窗口 (cwnd) 是 <code>发送端</code> 的限制</li></ul><p>限制谁呢？</p><p>限制的是 <code>发送窗口</code> 的大小</p><p>有了这两个窗口，如何来计算 <code>发送窗口</code> ？</p><pre><code class="language-HTTP">发送窗口 = min(rwnd, cwnd)
</code></pre><p>取两者的较小值，而拥塞控制，就是来控制 cwnd 的变化</p><h4 id="慢启动"><a class="anchor" href="#慢启动">#</a> 慢启动</h4><p>刚开始进入传输数据的时候，是不知道现在的网络到底是稳定还是拥堵的，如果做的太激进，发包太急，就会疯狂丢包，造成雪崩式的网络灾难</p><p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢的适应整个网络，这种算法叫 <code>慢启动</code> 。运作过程如下：</p><ul><li>首先，三次握手，双方宣告自己的接收窗口大小</li><li>双方初始化自己的<strong>拥塞窗口</strong> (cwnd) 的大小</li><li>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，以此类推</li></ul><p>难道就这么无止境的翻倍下去？当然不可能。它的阈值叫做<strong>慢启动阈值</strong>，当 cwnd 到达这个阈值后，就好比踩了刹车</p><p>在到达阈值后，如何控制 cwnd 的大小呢？</p><p>这就是拥塞避免做的事情了</p><h4 id="拥塞避免"><a class="anchor" href="#拥塞避免">#</a> 拥塞避免</h4><p>原来每收到一个 ACK，cwnd 加 1，现在到达阈值了，cwnd 只能加这么一点：<strong>1 / cwnd</strong>。这样一轮 RTT 下来，收到 cwnd 个 ACK，那最后拥塞窗口的大小 cwnd 总共才增加 1</p><p>也就是说，以前一个 RTT 下来， <code>cwnd</code> 翻倍，现在 <code>cwnd</code> 只是增加 1 而已</p><p>当然，<strong>慢启动</strong>和<strong>拥塞避免</strong>是一起作用的，是一体的</p><h4 id="快速重传和快速回复"><a class="anchor" href="#快速重传和快速回复">#</a> 快速重传和快速回复</h4><p><strong>快速重传</strong></p><p>在 TCP 传输过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK</p><p>比如第 5 个包丢了，即使第 6、7 个包到达了接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传</p><p>这就是<strong>快速重传</strong>，它解决的是<strong>是否需要重传</strong>的问题</p><p><strong>快速恢复</strong>（？）</p><p>当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络有些拥塞了，自己会进入<strong>快速恢复</strong>阶段</p><p>在这个阶段，发送端如下改变：</p><ul><li>拥塞阈值降低为 cwnd 的一半</li><li>cwnd 的大小变为拥塞阈值</li><li>cwnd 线性增加</li></ul><p>以上就是 TCP 拥塞控制的经典算法：<strong>慢启动、拥塞避免、快速重传和快速恢复</strong></p><hr><h3 id="11nagle-算法和延迟确认"><a class="anchor" href="#11nagle-算法和延迟确认">#</a> 11.Nagle 算法和延迟确认</h3><h4 id="nagle-算法"><a class="anchor" href="#nagle-算法">#</a> Nagle 算法</h4><p>试想一个场景，发送端不停的给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延</p><p>而避免小包的频繁发送，这就是<strong> Nagle 算法</strong>要做的事</p><p>具体来说，Nagle 算法的规则如下：</p><ul><li>当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送</li><li>后面发送满足下面条件之一就可以发送：<ul><li>数据包大小达到最大段大小 (Max Segment Size，即 MSS)</li><li>之前所有包的 ACK 都已接收到</li></ul></li></ul><h4 id="延迟确认"><a class="anchor" href="#延迟确认">#</a> 延迟确认</h4><p>试想一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那是要一个个回复，还是稍等一下，把两个包的 ACK 合并后一起回复呢？</p><p><strong>延迟确认</strong> (delayed ack) 所做的事情就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于 500ms，一般操作系统实现都不会超过 200ms</p><p>不过主要的是，有一些场景是不能延迟确认的，收到了就要马上回复：</p><ul><li>接收到了大于一个 frame 的报文，且需要调整窗口大小</li><li>TCP 处于 quickack 模式 (通过 <code>tcp_in_quickack_mode</code> 设置)</li><li>发现了乱序包</li></ul><h4 id="两者一起使用会怎样"><a class="anchor" href="#两者一起使用会怎样">#</a> 两者一起使用会怎样？</h4><p>前者意味着延迟发送，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p><hr><h3 id="12tcp-的-keep-alive"><a class="anchor" href="#12tcp-的-keep-alive">#</a> 12.TCP 的 keep-alive</h3><p>大家都听说过 HTTP 的 <code>keep-alive</code> ，不过 TCP 层面也是有 <code>keep-alive</code> 机制，而且跟应用层不太一样</p><p>试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的</p><p>这个时候就出现了 <code>keep-alive</code> ，它的作用就是探测对端的连接有没有失效</p><p>在 Linux 下，可以这样查看相关的配置</p><pre><code>sudo sysctl -a | grep keepalive

// 每隔 7200 s 检测一次
net.ipv4.tcp_keepalive_time = 7200
// 一次最多重传 9 个包
net.ipv4.tcp_keepalive_probes = 9
// 每个包的间隔重传间隔 75 s
net.ipv4.tcp_keepalive_intvl = 75
</code></pre><p>不过，现状是大部分的应用并没有默认开启 TCP 的 <code>keep-alive</code> 选项，为什么？</p><p>站在应用的角度:</p><ul><li>7200s 也就是两个小时检测一次，时间太长</li><li>时间再短一些，也难以体现其设计的初衷，即检测长时间的死连接</li></ul><p>因此是一个比较尴尬的设计。</p><div class="tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="ic i-tag"></i> 计算机基础</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-04-23 14:39:06" itemprop="dateModified" datetime="2022-04-23T14:39:06+08:00">2022-04-23</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sparkle 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sparkle 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="sparkle 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sparkle <i class="ic i-at"><em>@</em></i>Sparkle</li><li class="link"><strong>本文链接：</strong> <a href="https://1234cas.github.io/1234cas.github.io/Computer-Basics/TCP%E5%8D%8F%E8%AE%AE/" title="TCP协议">https://1234cas.github.io/1234cas.github.io/Computer-Basics/TCP协议/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Diary/2022-4-29%20%E9%9D%A2%E8%AF%95%E6%97%A5%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexj2jgzj20zk0m8b09.jpg" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/Diary/2021-11-14/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexbei4hj20zk0m8npd.jpg" title="2022-11-14."><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 日记</span><h3>2022-11-14.</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#01tcp-%E5%92%8C-udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">01.TCP 和 UDP 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="toc-number">2.</span> <span class="toc-text">02.TCP 三次握手的过程。为什么不是两次？不是四次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1"><span class="toc-number">2.2.</span> <span class="toc-text">为什么不是两次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="toc-number">2.3.</span> <span class="toc-text">为什么不是四次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E4%B9%88"><span class="toc-number">2.4.</span> <span class="toc-text">三次握手过程中可以携带数据么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%8F%91%E8%B5%B7%E6%8F%A1%E6%89%8B%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">2.5.</span> <span class="toc-text">同时发起握手会怎样</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">03. 四次挥手的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.1.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85-2msl-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.2.</span> <span class="toc-text">等待 2MSL 的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1"><span class="toc-number">3.3.</span> <span class="toc-text">为什么是四次挥手而不是三次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">3.4.</span> <span class="toc-text">同时关闭会怎样？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#04%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C-syn-flood-%E6%94%BB%E5%87%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">04. 半连接队列和 SYN Flood 攻击的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">半连接队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">全连接队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syn-flood-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">SYN Flood 攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9-syn-flood-%E6%94%BB%E5%87%BB"><span class="toc-number">4.4.</span> <span class="toc-text">如何应对 SYN Flood 攻击？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#05tcp-%E6%8A%A5%E6%96%87%E7%9A%84%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">5.</span> <span class="toc-text">05.TCP 报文的头部字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%AB%AF%E5%8F%A3-%E7%9B%AE%E6%A0%87%E7%AB%AF%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">源端口、目标端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">5.2.</span> <span class="toc-text">序列号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isn%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">5.3.</span> <span class="toc-text">ISN (初始序列号)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E5%8F%B7"><span class="toc-number">5.4.</span> <span class="toc-text">确认号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%8F%B7"><span class="toc-number">5.5.</span> <span class="toc-text">标记号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.6.</span> <span class="toc-text">窗口大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="toc-number">5.7.</span> <span class="toc-text">校验和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%A1%B9"><span class="toc-number">5.8.</span> <span class="toc-text">可选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#06tcp-%E5%BF%AB%E9%80%9F%E6%89%93%E5%BC%80%E7%9A%84%E5%8E%9F%E7%90%86tfo"><span class="toc-number">6.</span> <span class="toc-text">06.TCP 快速打开的原理 (TFO)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tfo-%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">TFO 流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tfo-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">6.2.</span> <span class="toc-text">TFO 的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07tcp-%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">7.</span> <span class="toc-text">07.TCP 报文中的时间戳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97-%E5%BE%80%E8%BF%94%E6%97%B6%E5%BB%B6-rtt"><span class="toc-number">7.1.</span> <span class="toc-text">计算 往返时延 RTT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E5%BA%8F%E5%88%97%E5%8F%B7%E7%9A%84%E5%9B%9E%E7%BB%95%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">防止序列号的回绕问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08tcp-%E7%9A%84%E8%B6%85%E6%97%B6%E9%87%8D%E8%BF%9E"><span class="toc-number">8.</span> <span class="toc-text">08.TCP 的超时重连</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">经典方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">标准方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09tcp-%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">09.TCP 的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">9.1.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3"><span class="toc-number">9.2.</span> <span class="toc-text">发送窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3"><span class="toc-number">9.3.</span> <span class="toc-text">接收窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">9.4.</span> <span class="toc-text">流量控制过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">10.TCP 的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3"><span class="toc-number">10.1.</span> <span class="toc-text">拥塞窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">10.2.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">10.3.</span> <span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E9%80%9F%E5%9B%9E%E5%A4%8D"><span class="toc-number">10.4.</span> <span class="toc-text">快速重传和快速回复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11nagle-%E7%AE%97%E6%B3%95%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-number">11.</span> <span class="toc-text">11.Nagle 算法和延迟确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nagle-%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">Nagle 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4"><span class="toc-number">11.2.</span> <span class="toc-text">延迟确认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">11.3.</span> <span class="toc-text">两者一起使用会怎样？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12tcp-%E7%9A%84-keep-alive"><span class="toc-number">12.</span> <span class="toc-text">12.TCP 的 keep-alive</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/Computer-Basics/TCP%E5%8D%8F%E8%AE%AE/" rel="bookmark" title="TCP协议">TCP协议</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sparkle" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sparkle</p><div class="description" itemprop="description">好好读书</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">35</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;instagram.com&#x2F;yourname"><i class="ic i-instagram"></i></span> <span class="exturl item skype" data-url="c2t5cGU6eW91cm5hbWU/Y2FsbHxjaGF0" title="skype:yourname?call|chat"><i class="ic i-skype"></i></span> <span class="exturl item douban" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveW91cm5hbWUv" title="https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yourname&#x2F;"><i class="ic i-douban"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Diary/2022-4-29%20%E9%9D%A2%E8%AF%95%E6%97%A5%E8%AE%B0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Diary/2021-11-14/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/Front-end/%E4%B8%80%E6%96%B9%E9%9D%A2/" title="分类于 一方面">一方面</a></div><span><a href="/Front-end/One-side/SVG/" title="SVG">SVG</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E7%A8%8B/" title="分类于 编程">编程</a></div><span><a href="/Programme/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="小程序">小程序</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/Reading-minutes/%E8%AF%BB%E4%B9%A6%E5%88%97%E8%A1%A8/" title="读书列表">读书列表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/Reading-minutes/js%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D/" title="js忍者秘籍">js忍者秘籍</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%85%B6%E4%BB%96/" title="分类于 其他">其他</a></div><span><a href="/Other/%E6%94%B6%E8%97%8F-%E5%AD%97%E9%9D%A2%E8%AE%B0%E5%BD%95/" title="收藏">收藏</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/Reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" title="关于笔记">关于笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E8%AE%B0/" title="分类于 日记">日记</a></div><span><a href="/Diary/2022-4-14/" title="2022-4-14">2022-4-14</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E8%AE%B0/" title="分类于 日记">日记</a></div><span><a href="/Diary/2022-4-4/" title="2022-4-4">2022-4-4</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%BC%96%E7%A8%8B/" title="分类于 编程">编程</a></div><span><a href="/Programme/%E7%BC%96%E7%A8%8B/" title="编程">编程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/Hexo/Hexo/" title="Hexo">Hexo</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sparkle @ Sparkle</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">681k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">10:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Computer-Basics/TCP协议/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->