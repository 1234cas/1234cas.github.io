<!-- build time:Tue Oct 31 2023 21:50:09 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://1234cas.github.io/1234cas.github.io/Algorithms/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B/"><title>| Sparkle = Sparkle = 加油</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2023-05-15 10:40:04"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-05-15T10:40:04+08:00">2023-05-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>43k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>39 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sparkle</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhtuo6nj20zk0m8ttm.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1234cas.github.io/1234cas.github.io/Algorithms/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sparkle"><meta itemprop="description" content="加油, 好好读书"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sparkle"></span><div class="body md" itemprop="articleBody"><h1 id="4-图graphs"><a class="anchor" href="#4-图graphs">#</a> 4. 图 (Graphs)</h1><h2 id="41-无向图undirected-graphs"><a class="anchor" href="#41-无向图undirected-graphs">#</a> 4.1 无向图 (Undirected Graphs)</h2><h3 id="定义与术语"><a class="anchor" href="#定义与术语">#</a> 定义与术语</h3><p>定义：图是又一组顶点和一组能够将两个顶点相连的边组成的</p><p><img data-src="%E4%B8%8B.assets/graph.png" alt="图形"></p><p>术语：</p><ul><li><p><strong>自环</strong>，即一条连接一个顶点和其自身的边</p></li><li><p>连接同一对顶点的两条边称为<strong>平行边</strong></p></li><li><p>当两个顶点通过一条边相连时，我们称这两个顶点是<strong>相邻</strong>的，并称该连接<strong>依附于</strong>这两个顶点。</p></li><li><p>某个顶点的<strong>度数</strong>即为顶点的边的总数。</p></li><li><p><strong>子图</strong>是由一幅图的所有边的一个子集组成的图</p></li><li><p><strong>路径</strong>是由边顺序连接的一系列顶点</p></li><li><p><strong>简单路径</strong>是一条没有重复顶点的路径</p></li><li><p><strong>环</strong>是一条至少含有一条边且终点和起点相同的路径</p></li><li><p><strong>简单环</strong>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环</p></li><li><p>路径和环的<strong>长度</strong>就是其中所包含的边数</p></li></ul><p>大多数情况下，我们研究的都是简单环和简单路径并会省略掉简单二字。当允许重复的顶点时，我们指的都是一般的路径和环。当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另个顶点是连通的。我们用类似 u-v-w-x 的记法来表示 u 到 x 的一条路径，用 u-v-w-x-u 表示从 u 到 v 到 w 到 x 再回到 u 的一条环。</p><ul><li><p>如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是<strong>连通图</strong>。</p></li><li><p>一幅<strong>非连通图</strong>由若干连通的部分组成，它们都是其极大连通子图。</p></li><li><p><strong>无环图</strong>是没有环的图。</p></li><li><p><strong>树</strong>是无环连通图</p></li><li><p>互不相连的树组成的集合称为<strong>森林</strong></p></li><li><p>连通图的<strong>生成树</strong>是它的一幅子图，它含有图中的所有顶点且是一棵树。</p></li><li><p>图的<strong>生成树森林</strong>是它的所有连通子图的生成树的集合</p></li></ul><p><img data-src="%E4%B8%8B.assets/image-20220808091312988.png" alt="image-20220808091312988"></p><ul><li><p><strong>二分图</strong>一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</p></li><li><p>图的<strong>密度</strong>是指已经连接的顶点对占所有可能被连接的顶点对的比例。在<strong>稀疏图</strong>中，被连接的顶点对很少；而在<strong>稠密图</strong>中，只有少部分顶点对之间没有边连接。一般来说，如果一幅图中不同的边的数</p></li></ul><p><img data-src="%E4%B8%8B.assets/image-20220808091526405.png" alt="image-20220808091526405"></p><h3 id="无向图数据类型"><a class="anchor" href="#无向图数据类型">#</a> 无向图数据类型</h3><p><img data-src="%E4%B8%8B.assets/graph-api.png" alt="图形 API"></p><p>这份 API 含有两个构造函数，有两个方法用来分别返回图中的顶点数和边数，有一 - 个方法用来添加一条边，toString () 方法和 adj () 方法用来允许用例遍历给定顶点的所有相邻顶点（遍历顺序不确定)。值得注意的是，本节将学习的所有算法都基于 adj () 方法所抽象的基本操作。</p><p><img data-src="%E4%B8%8B.assets/graph-input.png" alt="图形输入格式"></p><p>图形表示用<strong>邻接表数组</strong>。我们可以使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表。<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvR3JhcGguamF2YS5odG1s">Graph.java</span> 使用邻接列表表示来实现图 API。</p><p><img data-src="%E4%B8%8B.assets/adjacency-lists.png" alt="无向图的邻接表表示"></p><p>边的插入顺序决定了 Graph 的邻接表中顶点的出现顺序。多个不同的邻接表可能表示着同一幅图。这种差异不会影响算法的正确性，. 但在调试或是跟踪邻接表的轨迹时我们还是需要注意这一点。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span> <span class="token operator">=</span> <span class="token class-name">V</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>E</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        adj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Bag</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token class-name">In</span> in<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token keyword">this</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> <span class="token class-name">E</span> <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">E</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">int</span> v <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">int</span> w <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token function">addEdge</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">V</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">E</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">adj</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">return</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="深度优先搜索dfs"><a class="anchor" href="#深度优先搜索dfs">#</a> 深度优先搜索 (DFS)</h3><p>深度优先搜索是一种经典的递归方法，用于系统地检查图中的每个顶点和边。访问一个顶点。</p><ul><li>将其标记为已访问。</li><li>访问（递归）与其相邻且尚未标记的所有顶点。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvRGVwdGhGaXJzdFNlYXJjaC5qYXZhLmh0bWw=">DepthFirstSearch.java</span> 实现了这种方法和以下 API：</p><p><img data-src="%E4%B8%8B.assets/search-api.png" alt="搜索 API"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepthFirstSearch</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DepthFirstSearch</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">marked</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">return</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>命题 A。深度优先搜索标记与起点连通的所有顶点所需的时间和顶点的度数之和成正比。</p><p><img data-src="%E4%B8%8B.assets/image-20220808101754141.png" alt="image-20220808101754141"></p><p>解决了连通性和单点路径的问题</p><h3 id="寻找路径"><a class="anchor" href="#寻找路径">#</a> 寻找路径</h3><p>修改深度优先搜索很容易，不仅可以确定两个给定顶点之间是否存在路径，还可以找到这样的路径（如果存在）。我们寻求实现以下 API：</p><p><img data-src="%E4%B8%8B.assets/paths-api.png" alt="路径 API"></p><p>为了做到这一点，在由边 <code>vw</code> 第一次访问任意 <code>w</code> 时，将 <code>edgeTo[w]</code> 设置为 <code>v</code> 来记住这条路径。换句话说， <code>vw</code> 是从 <code>s</code> 到 <code>w</code> 的路径上的最后一条已知的边。搜索的结果是一棵以起点为根结点的树； <code>edgeTo[]</code> 是一颗由父链接表示的树。 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvRGVwdGhGaXJzdFBhdGhzLmphdmEuaHRtbA==">DepthFirstPaths.java</span> 实现了这种方法。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepthFirstPaths</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DepthFirstPaths</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">=</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">pathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPathTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> v<span class="token punctuation">;</span> x <span class="token operator">!=</span> s<span class="token punctuation">;</span> x <span class="token operator">=</span> edgeTo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> path<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220808102546735.png" alt="image-20220808102546735"></p><p>命题 A (续）。使用深度优先搜索得到从给定起点到任意标记顶点的路径所需的时间与路径的长度成正比。</p><p><img data-src="%E4%B8%8B.assets/image-20220808102851183.png" alt="image-20220808102851183"></p><h3 id="广度优先搜索bfs"><a class="anchor" href="#广度优先搜索bfs">#</a> 广度优先搜索 (BFS)</h3><p>深度优先搜索找到从源顶点 s 到目标顶点 v 的一些路径。我们经常对找到最短的这样的路径感兴趣（一条边数最少的路径）。广度优先搜索是基于此目标的经典方法。</p><p>为了找到从 s 到 v 的最短路径，我们从 s 开始，在沿着一条边可以到达的所有顶点中检查 v，然后在沿着两条边从 s 可以到达的所有顶点中检查 v，一直下去直到找到。深度优先搜索就好像是一个人在走迷宫，广度优先搜索则好像是一组人在一起朝各个方向走这座迷宫，每个人都有自己的绳子。当出现新的叉路时；可以假设一个探索者可以分裂为更多的人来搜索它们，当两个探索者相遇时，会合二为一（并继续使用先到达者的绳子）。</p><p><img data-src="%E4%B8%8B.assets/image-20220808103306284.png" alt="image-20220808103306284"></p><p>为了实现这一策略，我们维护了一个队列，其中包含已标记但尚未检查其邻接表的所有顶点。我们将起点放入队列中，然后执行以下步骤直到队列为空：</p><ul><li>取队列中的下一个顶点 v 并标记它。</li><li>将与 v 相邻的所有未标记顶点放入队列。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvQnJlYWR0aEZpcnN0UGF0aHMuamF2YS5odG1s">BreadthFirstPaths.java</span> 是查找最短路径的 <code>Paths API 的实现。</code> 它依赖<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvUXVldWUuamF2YS5odG1s"> Queue.java</span> 作为 FIFO 队列。</p><p><img data-src="%E4%B8%8B.assets/image-20220808104059507.png" alt="image-20220808104059507"></p><p><img data-src="%E4%B8%8B.assets/image-20220808104145890.png" alt="image-20220808104145890"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BreadthFirstPaths</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INFINITY <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>      </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> distTo<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">BreadthFirstPaths</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        marked<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">int</span> v <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token function">pathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPathTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> v<span class="token punctuation">;</span> distTo<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">=</span> edgeTo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token keyword">return</span> path<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>命题 B。对于从 S 可达的任意顶点 v, 广度优先搜索都能找到一条从 s 到 v 的最短路径 (没有其他从 s 到 v 的路径所含的边比这条路径更少)。</p><p>命题 B (续)。广度优先搜索所需的时间在最坏情况下和 V+E 成正比。</p><p>我们在本章开头说过，深度优先搜索和广度优先搜索是我们首先学习的几种通用的图搜索的算法之一。在搜索中我们都会先将起点存入数据结构中，然后重复以下步骤直到数据结构被清空:</p><ul><li>取其中的下一个顶点并标记它；</li><li>将 v 的所有相邻而又未被标记的顶点加入数据结构。</li></ul><p>这两个算法的不同之处仅在于从数据结构中获取下一个顶点的规则 **(对于广度优先搜索来说是最早加入的顶点，对于深度优先搜索来说是最晚加入的顶点）**。这种差异得到了处理图的两种完全不同的视角，尽管无论使用哪种规则，所有与起点连通的顶点和边都会被检查到。</p><p><img data-src="%E4%B8%8B.assets/image-20220808105015430.png" alt="image-20220808105015430"></p><h3 id="连通分量"><a class="anchor" href="#连通分量">#</a> 连通分量</h3><p>连通为一组，连通分量即为连通组数</p><p><img data-src="%E4%B8%8B.assets/cc-api.png" alt="连接组件 API"></p><p>递归的深度优先搜索第一次调用的参数是顶点 0，它会标记所有与 0 连通的顶点。然后构造函数中的 for 循环会查找每个没有被标记的顶点并递归调用 dfs (来标记和它相邻的所有顶点。另外，它还使用了一个以顶点作为索引的数组 id [] ，将同一个连通分量中的顶点和连通分量的标识符关联起来 ( int 值)。</p><p>这里的实现是基于一个由顶点索引的数组 id [] 。如果 v 属于第 i 个连通分量，则 id [v] 的值为 i 。构造函数会找出一个未被标记的顶点并调用递归函数 dfs () 来标记并区分出所有和它连通的顶点，如此重复直到所有的顶点都被标记并区分。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvQ0MuamF2YS5odG1s">CC.java</span> 使用 DFS 来实现这个 API。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> CC <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> id<span class="token punctuation">;</span>           </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token function">CC</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        id<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> id<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">return</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">id</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">id</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>命题 C。深度优先搜索的预处理使用的时间和空间与 V+E 成正比且可以在常数时间内处理关于图的连通性查询。</p><p>CC 中基于深度优先搜索来解决图连通性问题的方法与第 1 章中的 union-find 算法相比孰优孰劣？理论上，深度优先搜索比 union-find 法快，因为它能保证所需的时间是常数而 union-find 算法不行；但在实际应用中，这点差异微不足道。union-find 算法其实更快，因为它不需要完整地构造并表示一幅图。更重要的是，union-find 算法是一种动态算法（我们在任何时候都能用接近常数的时间检查两个顶点是否连通，甚至是在添加一条边的时候)，但深度优先搜索则必须要对图进行预处理。因此，<strong>我们在完成只需要判断连通性或是需要完成有大量连通性查询和插入操作混合等类似的任务时，更倾向使用 union-find 算法，而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。</strong></p><p><img data-src="%E4%B8%8B.assets/image-20220808120453652.png" alt="image-20220808120453652"></p><p>G 是无环图吗？（假设不存在自环或平行边)：<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvQ3ljbGUuamF2YS5odG1s">Cycle.java</span> 使用深度优先搜索来确定一个图是否有一个循环，如果有则返回一个。在最坏的情况下，它需要与 V + E 成正比的时间。</p><p>G 是二分图吗？(双色问题)：<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvQmlwYXJ0aXRlLmphdmEuaHRtbA==">Bipartite.java</span> 使用深度优先搜索来判断一个图是否有二分；如果是，则返回一个；如果不是，则返回一个奇数长度的循环。在最坏的情况下，它需要与 V + E 成正比的时间。</p><h3 id="符号图"><a class="anchor" href="#符号图">#</a> 符号图</h3><p>典型应用涉及使用字符串而不是整数索引来定义和引用顶点的处理图。为了适应此类应用程序，我们定义了具有以下属性的输入格式：</p><ul><li>顶点名称是字符串。</li><li>指定的分隔符分隔顶点名称（以允许名称中包含空格）。</li><li>每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点；</li><li>顶点总数 V 和边的总数 E 都是隐式定义的</li></ul><p><img data-src="%E4%B8%8B.assets/routes-165993194618618.png" alt="航线"></p><p>API</p><p><img data-src="%E4%B8%8B.assets/symbol-graph-api.png" alt="符号图 API"></p><p>用 name () 方法和 index () 方法将输人流中的顶点名和图算法使用的顶点索引对应起来。</p><p><img data-src="%E4%B8%8B.assets/movies.png" alt="电影演员图"></p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvU3ltYm9sR3JhcGguamF2YS5odG1s">SymbolGraph.java</span> 实现了 API。它构建了三个数据结构：</p><ul><li>一个符号表 st，带有 <code>String</code> 键（顶点名称）和 <code>int</code> 值（索引）</li><li>一个数组 keys [] ，用作反向索引，保存每个顶点索引所对应的顶点名</li><li>一个 Graph 对象 G ，它使用索引来引用图中顶点</li></ul><p>这个 Graph 实现允许用例用字符串代替数字索引来表示图中的顶点。它维护了实例变量 st (符号表用来映射顶点名和索引)、keys（数组用来映射索引和顶点名）和 G (使用索引表示顶点的图)。为了构造这些数据结构，代码会将图的定义处理两遍。</p><p><img data-src="%E4%B8%8B.assets/symbol-graph.png" alt="符号图数据结构"></p><p>这个 Graph 实现允许用例用字符串代替数字索引来表示图中的顶点。它维护了实例变量 st (符号表用来映射顶点名和索引)、keys (数组用来映射索引和顶点名) 和 G (使用索引表示顶点的图)。为了构造这些数据结构，代码会将图的定义处理两遍 (定义的每一行都包含一个顶点及它的相邻顶点列表，用分隔符 sp 隔开)。</p><p><strong>间隔的度数</strong>。图处理的一个经典向题就是，找到一个社交网络之中两个人间隔的度数。就是两个人间的最短路径。<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvRGVncmVlc09mU2VwYXJhdGlvbi5qYXZhLmh0bWw=">DegreesOfSeparation.java</span> 使用广度优先搜索来查找社交网络中两个人之间的分离程度。对于演员 - 电影图，它播放 Kevin Bacon 游戏。</p><h2 id="42-有向图directed-graphs"><a class="anchor" href="#42-有向图directed-graphs">#</a> 4.2 有向图 (Directed Graphs)</h2><h3 id="定义与术语-2"><a class="anchor" href="#定义与术语-2">#</a> 定义与术语</h3><p>在有向图中，边是单向的：每条边所连接的两个顶点都是一个有序对</p><p>定义。一幅有方向性的图 (或有向图) 是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点。</p><ul><li><p>顶点的<strong>出度</strong>是它指出的边数。</p></li><li><p>顶点的入度是指向它的边数。</p></li><li><p>一条有向边的第一个顶点称为它的<strong>头</strong>，第二个顶点则被称为它的<strong>尾</strong>。用 v→w 来表示有向图中一条由 v 指向 w 的边。</p></li><li><p><strong>有向路径</strong>由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点。</p></li><li><p><strong>有向环</strong>为一条至少含有一条边且起点和终点相同的有向路径。</p></li><li><p><strong>简单有向环</strong>是一条 (除了起点和终点必须相同之外）不含有重复的顶点和边的环。</p></li><li><p>路径或者环的<strong>长度</strong>即为其中所包含的边数。</p></li><li><p>如果存在从 v 到 w 的有向路径，称顶点 w 可以由顶点 v <strong>到达</strong>。</p></li><li><p>如果两个顶点 v 和 w 是相互可达的：有一条从 v 到 w 的有向路径和一条从 w 到 v 的有向路径，则称为 v 和 w 是<strong>强连接</strong>的。</p></li><li><p>如果从每个顶点到其他每个顶点都有一条有向路径，则<strong>有向图是强连通的</strong>。</p></li><li><p>非强连通的有向图由一组强连通分量 组成，它们是<strong>最大强连通子图</strong>。</p></li><li><p><strong>有向无环图</strong>（或 DAG）是没有有向环的有向图。</p></li></ul><p><img data-src="%E4%B8%8B.assets/strong-components.png" alt="有向图及其强组件"></p><h3 id="有向图数据类型"><a class="anchor" href="#有向图数据类型">#</a> 有向图数据类型</h3><p><img data-src="%E4%B8%8B.assets/digraph-api.png" alt="有向图 API"></p><p>关键方法 <code>adj()</code> 允许客户端代码遍历与给定顶点相邻的顶点。</p><p><img data-src="%E4%B8%8B.assets/digraph-input.png" alt="有向图输入格式"></p><p><img data-src="%E4%B8%8B.assets/adjacency-lists-16600251879595.png" alt="无向图的邻接表表示"></p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQyZGlncmFwaC9EaWdyYXBoLmphdmEuaHRtbA==">Digraph.java</span> 使用邻接列表表示来实现有向图 API。Digraph 数据类型与 Graph 数据类型基本相同，区别是 addEdge 只调用了一次 add ()，而且它还有一个 reverse () 方法来返回图的反向图。</p><p>在有向图中，允许用例使用符号作为顶点名也更加简单。要实现与 SymbolGraph 类似的 SymbolDigraph 类，只需要将其中的 Graph 字样都替换成 Digraph 即可。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Digraph</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Digraph</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">Digraph</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Digraph</span><span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">:</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>               	<span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">R</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="有向图的可达性"><a class="anchor" href="#有向图的可达性">#</a> 有向图的可达性</h3><p>在无向图中介绍的第一个算法就是 4.1.3.2 节中的 DepthFirstSearch，它解决了单点连通性的问题，使得用例可以判定其他顶点和给定的起点是否连通。<strong>使用完全相同的代码</strong>，将其中的 Graph 替换为 Digraph，就可以解决一个有向图中的类似问题。</p><p><strong>单点可达性</strong>。给定一幅有向图和一个起点 s，回答 “是否存在一条从 s 到达给定顶点 v 的有向路径？” 等类似问题。</p><p><strong>多点可达性</strong>。给定一幅有向图和顶点的集合，回答 “是否存在一条从集合中的任意顶点到达给定顶点 v 的有向路径？” 等类似问题。</p><p>命题 D。在有向图中，深度优先搜索标记由一个集合的顶点可达的所有顶点所需的时间与被标记的所有顶点的出度之和成正比。</p><p>DepthFirstPaths (4.1.4.1 节算法 4.1）和 BreadthFirstPaths ( 4.1.5. 节算法 4.2）也都是有向图处理中的重要算法。和刚才一样，<strong>同样的 API 和代码</strong> (仅将 Graph 替换为 Digraph) 也能够高效地解决以下问题。</p><p><strong>单点有向路径</strong>。给定一幅有向图和一个起点 s，回答 “从 s 到给定目的顶点 v 是否存在一条有向路径？如果有，找出这条路径。” 等类似问题。</p><p><strong>单点最短有向路径</strong>。给定一幅有向图和一个起点 s ，回答 “从 s 到给定目的顶点 v 是否存在一条有向路径？如果有，找出其中最短的那条 (所含边数最少)。” 等类似问题。</p><p><img data-src="%E4%B8%8B.assets/image-20220809152159538.png" alt="image-20220809152159538"></p><h3 id="环和有向无环图dag"><a class="anchor" href="#环和有向无环图dag">#</a> 环和有向无环图 (DAG)</h3><p>原则上来说，一幅有向图可能含有大量的环；在实际应用中，我们一般只会重点关注其中一小部分，或者只想知道它们是否存在</p><p>调度问题。一种应用广泛的模型是给定一组任务并安排它们的执行顺序，限制条件是这些任务的执行方法和起始时间。限制条件还可能包括任务的时耗以及消耗的其他资源。最重要的一种限制条件叫做优先级限制，它指明了哪些任务必须在哪些任务之前完成。</p><p>优先级限制下的调度问题。等价于<strong>拓扑排序</strong>。给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素 (或者说明无法做到这一点)。</p><p><img data-src="%E4%B8%8B.assets/dag.png" alt="有向无环图"></p><p><img data-src="%E4%B8%8B.assets/topological-sort.png" alt="拓扑排序"></p><p>一般来说，如果一个有优先级限制的问题中存在有向环，那么这个问题肯定是无解的。要检查这种错误，需要解决下面这个问题。</p><p><strong>有向环检测</strong>。给定的有向图中包含有向环吗？如果有，按照路径的方向从某个顶点并返回自己来找到环上的所有顶点。<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQyZGlncmFwaC9EaXJlY3RlZEN5Y2xlLmphdmEuaHRtbA==">DirectedCycle.java</span> 使用深度优先搜索解决了这个问题。</p><p><img data-src="%E4%B8%8B.assets/image-20220809153253395.png" alt="image-20220809153253395"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectedCycle</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>      </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> onStack<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> cycle<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DirectedCycle</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        marked  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        onStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        edgeTo  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> cycle <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        onStack<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// short circuit if directed cycle found</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cycle <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// found new vertex, so recur</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">// trace back directed cycle</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>onStack<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                cycle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> v<span class="token punctuation">;</span> x <span class="token operator">!=</span> w<span class="token punctuation">;</span> x <span class="token operator">=</span> edgeTo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    cycle<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                cycle<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                cycle<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token keyword">assert</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        onStack<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>命题 E。当且仅当一幅有向图是无环图时它才能进行拓扑排序。</p><p>该类为标准的递归 dfs () 方法添加了一个布尔类型的数组 onStack [] 来保存递归调用期间栈上的所有顶点。当它找到一条边 v→w 且 w 在栈中时，它就找到了一个有向环。环上的所有顶点可以通过 edgeTo [] 中的链接得到。</p><p>在执行 dfs (G,v) 时，查找的是一条由起点到 v 的有向路径。要保存这条路径，DirectedCycle 维护了一个由顶点索引的数组 onStack []，以标记递归调用的栈上的所有顶点（在调用 dfs (G,v) 时将 onStack [v] 设为 true，在调用结束时将其设为 false )。DirectedCycle 同时也使用了一个 edgeTo [] 数组，在找到有向环时返回环中的所有顶点，方法和 DepthFirstPaths (请见算法 4.1）以及 BreadthFirstPaths（请见算法 4.2）相同。</p><p><strong>顶点的深度优先次序与拓扑排序</strong>。</p><p>实际上我们已经见过一种拓扑排序的算法：只要添加一行代码，标准深度优先搜索程序就能完成这项任务！它的基本思想是深度优先搜索正好只会访问每个顶点一次。如果将 dfs () 的参数顶点保存在一个数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个数据结构的性质以及是在递归调用之前还是之后进行保存。在典型的应用中，人们感兴趣的是顶点的以下 3 种排列顺序。</p><ul><li>前序：在递归调用之前将顶点加入队列。</li><li>后序：在递归调用之后将顶点加入队列。</li><li>逆后序：在递归调用之后将顶点压入栈。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQyZGlncmFwaC9EZXB0aEZpcnN0T3JkZXIuamF2YS5odG1s">DepthFirstOrder.java</span> 计算这些顺序。</p><p><img data-src="%E4%B8%8B.assets/depth-first-orders.png" alt="前序、后序和反向后序"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepthFirstOrder</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">;</span>       </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> post<span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> preorder<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> postorder<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> preCounter<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> postCounter<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DepthFirstOrder</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        pre    <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        post   <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        postorder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        preorder  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        marked    <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        pre<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> preCounter<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        preorder<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        postorder<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        post<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> postCounter<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">Topological</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">let</span> order</pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">let</span> rank <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">let</span> finder <span class="token operator">=</span> <span class="token function">DirectedCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    finder<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>finder<span class="token punctuation">.</span><span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token keyword">let</span> dfs <span class="token operator">=</span> <span class="token function">DepthFirstOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      dfs<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      order <span class="token operator">=</span> dfs<span class="token punctuation">.</span><span class="token function">reversePost</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      rank <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> order<span class="token punctuation">.</span><span class="token function">arrmethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        rank<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">++</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><em>拓扑排序</em>：给定一个有向图，将顶点按顺序排列，使其所有有向边从顺序较早的顶点指向顺序较晚的顶点（或报告这样做是不可能的）。 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQyZGlncmFwaC9Ub3BvbG9naWNhbC5qYXZhLmh0bWw=">Topological.java</span> 使用深度优先搜索解决了这个问题。值得注意的是，DAG 中的反向后序提供了拓扑顺序。</p><p>在给定的有向图包含环时，order () 方法会返回 null ，否则会返回一个能够给出拓扑有序的所有顶点的迭代器。这里省略了关于 SymbolDigraph 的代码，因为它和 SymbolGraph 的代码几乎完全相同，只需把所有的 Graph 替换为 Digraph 即可。</p><p>命题 F。一幅有向无环图的拓扑排序即为所有顶点的逆后序排列。</p><p>命题 G。使用深度优先搜索对有向无环图进行拓扑排序所需的时间和 V+E 成正比。</p><p>证明。由代码可知，第一遍深度优先搜索保证了不存在有向环，第二遍深度优先搜索产生了顶点的逆后序排序。两次搜索都访问了所有的顶点和所有的边，因此它所需的时间和 V+E 成正比。</p><p>在实际应用中，拓扑排序和有向环的检测总会一起出现，因为有向环的检测是排序的前提。因此，解决任务调度类应用通常需要以下 3 步:</p><ul><li>指明任务和优先级条件；</li><li>不断检测并去除有向图中的所有环，以确保存在可行方案的</li><li>使用拓扑排序解决调度问题。</li></ul><h3 id="有向图中的强连通性"><a class="anchor" href="#有向图中的强连通性">#</a> 有向图中的强连通性</h3><p>定义。如果两个顶点 v 和 w 是互相可达的，则称它们为强连通的。也就是说，既存在一条从 v 到 w 的有向路径，也存在一条从 w 到 v 的有向路径。如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的。</p><p>强连通性将所有顶点分为了一些平等的部分，每个部分都是由相互均为强连通的顶点的最大子集组成的。我们将这些子集称为强连通分量。</p><p><img data-src="%E4%B8%8B.assets/image-20220809170130479.png" alt="image-20220809170130479"></p><p>强连通分量 API</p><p><img data-src="%E4%B8%8B.assets/scc-api.png" alt="强大组件的 API"></p><p>Kosaraju 算法。我们在 CC (请见算法 4.3) 中看到过，计算无向图中的连通分量只是深度优先搜索的一个简单应用。那么在有向图中应该如何高效地计算强连通分量呢？令人惊讶的是，算法 4.6 中的 KosarajuCC 的实现只为 CC 添加了几行代码就做到了这一点，它将会完成以下任务 (请见图 4.2.15)：</p><ul><li>在给定的一幅有向图 G 中，使用 DepthFirstoOrder 来计算它的反向图 G r 的逆后序排列。</li><li>在 G 中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点。</li><li>在构造函数中，所有在同一个递归 dfs () 调用中被访问到的顶点都在同一个强连通分量中将它们按照和 CC 相同的方式识别出来。</li></ul><p><img data-src="%E4%B8%8B.assets/image-20220809170424679.png" alt="image-20220809170424679"></p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre>Kosaraju <span class="token keyword">function</span> <span class="token function">KosarajuSharirSCC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">let</span> marked <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">let</span> size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">let</span> dfo <span class="token operator">=</span> <span class="token function">DepthFirstOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    dfo<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span>  dfo<span class="token punctuation">.</span><span class="token function">reversePost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arrmethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        count<span class="token operator">++</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span><span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    id<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> count</pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> size<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">else</span> size<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token operator">++</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">adjArr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>i<span class="token punctuation">.</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">,</span> i<span class="token punctuation">.</span>item<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">rcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">return</span> count</pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">stronglyConnected</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> w</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">return</span> id<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> id<span class="token punctuation">[</span>w<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">rid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">return</span> id</pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">rsize</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">return</span> size<span class="token punctuation">[</span>id<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="39"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>值得注意的是，<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQyZGlncmFwaC9Lb3NhcmFqdVNoYXJpclNDQy5qYXZhLmh0bWw=">KosarajuSharirSCC.java</span> 仅在<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQxZ3JhcGgvQ0MuamF2YS5odG1s"> CC.java</span> 中添加了几行代码即可实现 API 。为了找到所有强连通分量，它会在反向图中进行深度优先搜索来将顶点排序（搜索顺序的逆后序），在给定有向图中用这个顺序再进行一次深度优先搜索。</p><p>命题 H。使用深度优先搜索查找给定有向图 G 的反向图 Gr , 根据由此得到的所有顶点的逆后序再次用深度优先搜索处理有向图 G (Kosaraju 算法)，其构造函数中的每一次递归调用所标记的顶点都在同一个强连通分量之中。</p><p><img data-src="%E4%B8%8B.assets/image-20220809173240281.png" alt="image-20220809173240281"></p><p>命题 I。Kosaraju 算法的预处理所需的时间和空间与 V+E 成正比且支持常数时间的有向图强连通性的查询。</p><p>定义。有向图 G 的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从 v 指向 w 的边当且仅当在 G 中 w 是从 v 可达的。</p><p><img data-src="%E4%B8%8B.assets/transitive-closure.png" alt="传递闭包"></p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQyZGlncmFwaC9UcmFuc2l0aXZlQ2xvc3VyZS5qYXZhLmh0bWw=">TransitiveClosure.java</span> 通过从每个顶点运行深度优先搜索并存储结果来计算有向图的传递闭包。这个解决方案对于小型或密集的有向图是理想的，但它不是我们在实践中可能遇到的大有向图的解决方案，因为构造函数使用与 V^2 成正比的空间和与 V (V + E) 成正比的时间。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">TransitiveClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    d <span class="token operator">=</span> <span class="token function">DirectedDFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    d<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      d<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">DirectedDFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      d<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">reachable</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> w</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">rmarked</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="43-最小生成树minimum-spanning-trees"><a class="anchor" href="#43-最小生成树minimum-spanning-trees">#</a> 4.3 最小生成树 (Minimum Spanning Trees)</h2><h3 id="概念和原理"><a class="anchor" href="#概念和原理">#</a> 概念和原理</h3><p>加权图是一种为每条边关联一个权值或是成本的图模型</p><p>定义。图的<strong>生成树</strong>是它的一棵含有其所有顶点的无环连通子图。一幅加权无向图的<strong>最小生成树</strong> (MST) 是它的一棵权值 (树中所有边的权值之和) 最小的生成树。</p><p><img data-src="%E4%B8%8B.assets/mst.png" alt="最小生成树"></p><p>一些约定。只考虑连通图。边的权重不一定表示距离。边的权重可能是 0 或者负数。所有边的权重都各不相同。事实上这个假设并没有限制算法的适用范围，因为不做修改它们也能处理存在等值权重的情况。</p><p><img data-src="%E4%B8%8B.assets/image-20220810153847346.png" alt="image-20220810153847346"></p><p>树的性质</p><ul><li>用一条边连接树中的任意两个顶点都会产生一个新的环；</li><li>从树中删去一条边将会得到两棵独立的树。</li></ul><p>我们称之为切分定理的这条性质将会把加权图中的所有顶点分为两个集合、检查横跨两个集合的所有边并识别哪条边应属于图的最小生成树。</p><p>定义。图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合。横切边是一条连接两个属于不同集合的顶点的边。</p><p><img data-src="%E4%B8%8B.assets/image-20220810154015848.png" alt="image-20220810154015848"></p><p>命题 J (切分定理)。在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。</p><p>在假设所有的边的权重均不相同的前提下，每幅连通图都只有一棵唯一的最小生成树，切分定理也表明了对于每一种切分，权重最小的横切边必然属于最小生成树。</p><p>切分定理是解决最小生成树问题的所有算法的基础。更确切的说，这些算法都是一种贪心算法的特殊情况：使用切分定理找到最小生成树的一条边，不断重复直到找到最小生成树的所有边。这些算法相互之间的不同之处在于保存切分和判定权重最小的横切边的方式，但它们都是以下性质的特殊情况。</p><p>命题 K (最小生成树的贪心算法)。下面这种方法会将含有 V 个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。反复，直到标记了 V-1 条黑色边为止。</p><h3 id="加权无向图数据类型"><a class="anchor" href="#加权无向图数据类型">#</a> 加权无向图数据类型</h3><p>加权无向图的表示方法：在邻接矩阵的表示中，可以用边的权重代替布尔值来作为矩阵的元素；在邻接表的表示中，可以在链表的结点中增加一个权重域。</p><p>any <code>()</code> 和 <code>other()</code> 方法对于访问边的顶点很有用； <code>compareTo()</code> 方法按权重比较边缘。 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L0VkZ2UuamF2YS5odG1s">Edge.java</span> 是一个简单的实现。</p><p><img data-src="%E4%B8%8B.assets/edge-api.png" alt="API for a weighted edge"></p><p>我们允许平行边和自环。 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L0VkZ2VXZWlnaHRlZEdyYXBoLmphdmEuaHRtbA==">EdgeWeightedGraph.java</span> 使用邻接列表表示来实现 API。<img data-src="%E4%B8%8B.assets/edge-weighted-graph-api.png" alt="API for an edge-weighted graph"></p><p>这份 API 和 Graph 的 API 非常相似。两者的两个重要的不同之处在于本节 API 的基础是 Edge 且添加了一个 edges 方法来遍历图的所有边 (忽略自环)。后面框注 “加权无向图的数据类型” 中 EdgeweightedGraph 的实现的其他部分与 4.1 节的无环图的实现基本相同，只是在邻接表中用 Edge 对象替代了 Graph 中的整数来作为链表的结点。</p><p><img data-src="%E4%B8%8B.assets/edge-weighted-graph-representation.png" alt="edge-weighted graph representation"></p><pre><code>
</code></pre><pre><code>
</code></pre><p>MST API.</p><p><img data-src="%E4%B8%8B.assets/mst-api.png" alt="API for MST implementations"></p><h3 id="prim算法"><a class="anchor" href="#prim算法">#</a> Prim 算法</h3><p>命题 L。 Prim 算法能够得到任意加权无向图的最小生成树。</p><p>添加顶点和横切边到最小生成树中，将顶点相邻的点添加到优先队列。两个顶点都在最小生成树的边失效。</p><p><strong>延时实现。</strong></p><p><img data-src="%E4%B8%8B.assets/prim-lazy.png" alt="最小生成树问题的 Prim 算法（惰性实现）"></p><p>命题 M。Prim 算法的延时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间与 E 成正比，所需的时间与 ElogE 成正比 (最坏情况）。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L0xhenlQcmltTVNULmphdmEuaHRtbA==">LazyPrimMST.java</span> 是这种惰性方法的实现。它依赖于 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L01pblBRLmphdmEuaHRtbA==">MinPQ.java</span> 优先级队列。</p><pre><code>lazyprimmst
</code></pre><p>Prim 算法的这种实现使用了一条优先队列来保存所有的横切边、一个由顶点索引的队列来标记树的顶点以及一条队列来保存最小生成树的边。这种延时实现会在优先队列中保留失效的边。</p><p><strong>即时实现</strong></p><p>简而言之，我们不需要在优先队列中保存所有从 w 到树顶点的边 —— 而只需要保存其中权重最小的那条，在将 v 添加到树中后检查是否需要更新这条权重最小的边 (因为 v-w 的权重可能更小)。</p><p>换句话说，我们只会在优先队列中保存每个非树顶点 w 的一条边：将它与树中的顶点连接起来的权重最小的那条边。将 w 和树的顶点连接起来的其他权重较大的边迟早都会失效，所以没必要在优先队列中保存它们。</p><p>这些性质的关键在于优先队列中的最小键即是权重最小的横切边的权重，而和它相关联的顶点 v 就是下一个将被添加到树中的顶点。</p><p>要维护这些数据结构，PrimMST 会从优先队列中取出一条边 v 并检查它的邻接链表中的每条边 v-w。如果 w 已经被标记过，那么这条边就已经失效了；如果 w 不在优先队列中或者 v-w 的权重小于目前已知的最小值 edgeTo [w]，代码会更新数组，将 v-w 作为将 v 和树连接的最佳选择。</p><p><img data-src="%E4%B8%8B.assets/prim-eager.png" alt="最小生成树问题的 Prim 算法（急切实现）"></p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L1ByaW1NU1QuamF2YS5odG1s">PrimMST.java</span> 是这种急切方法的实现。它依靠 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L0luZGV4TWluUFEuamF2YS5odG1s">IndexMinPQ.java</span> 索引优先级队列来执行<em>减少键</em>操作。</p><pre><code>Primmst
</code></pre><p>命题 N。Prim 算法的即时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的空间和 V 成正比，所需的时间和 ElogV 成正比（最坏情况)。</p><p><img data-src="%E4%B8%8B.assets/image-20220810205453339.png" alt="image-20220810205453339"></p><h3 id="kruskal算法-用于最小生成树问题的-kruskal-算法"><a class="anchor" href="#kruskal算法-用于最小生成树问题的-kruskal-算法">#</a> Kruskal 算法 <img data-src="%E4%B8%8B.assets/kruskal.png" alt="用于最小生成树问题的 Kruskal 算法"></h3><p>程序<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L0tydXNrYWxNU1QuamF2YS5odG1s"> KruskalMST.java</span> 按照这些思路实现了 Kruskal 算法。它使用助手 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L01pblBRLmphdmEuaHRtbA==">MinPQ.java</span>、 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L1VGLmphdmEuaHRtbA==">UF.java</span> 和 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQzbXN0L1F1ZXVlLmphdmEuaHRtbA==">Queue.java</span> 数据类型</p><p>命题 N (续)。Kruskal 算法的计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最 小生成树所需的空间和 E 成正比，所需的时间和 ElogE 成正比最坏情况）。</p><pre><code>
</code></pre><p><img data-src="%E4%B8%8B.assets/image-20220810205444544.png" alt="image-20220810205444544"></p><h2 id="44-最短路径shortest-paths"><a class="anchor" href="#44-最短路径shortest-paths">#</a> 4.4 最短路径 (Shortest Paths)</h2><h3 id="概念"><a class="anchor" href="#概念">#</a> 概念</h3><p>找到从一个顶点到达另一个顶点的成本最小的路径。</p><p>在 4.2 节中我们希望知道从一个顶点是否可以到达另一个顶点。在本节中，我们会把权重考虑进来，就像在 4.3 节中研究的加权无向图那样。<strong>在加权有向图中，每条有向路径都有一个与之关联的路径权重，它是路径中的所有边的权重之和</strong>。这种重要的度量方式使得我们能够将这个问题归纳为 “找到从一个顶点到达另一个顶点的权重最小的有向路径”，也就是本节的主题。</p><p><img data-src="%E4%B8%8B.assets/shortest-path.png" alt="最短路径"></p><p>定义。在一幅加权有向图中，从顶点 s 到顶点 t 的最短路径是所有从 s 到 t 的路径中的权重最小者。</p><p><strong>单点最短路径</strong>。给定一幅加权有向图和一个起点 s, 回答 “从 s 到给定的目的顶点 v 是否存在一条有向路径？如果有，找出最短 (总权重最小) 的那条路径。”</p><p>最短路径特性。路径是有向的。权重不一定等于距离。并不是所以顶点都是可达的。负权重会使问题更复杂。最短路径一般都是简单的。最短路径不一定是唯一的。可能存在平行边和环。</p><p>单点最短路径问题。计算结果是一颗最短路径树 (SPT)，它包含了顶点 s 到所有可达的顶点的最短路径。</p><p><img data-src="%E4%B8%8B.assets/image-20220811210133272.png" alt="image-20220811210133272"></p><p>定义。给定一幅加权有向图和一个顶点 s, 以 s 为起点的一棵最短路径树是图的一幅子图，它包含 s 和从 s 可达的所有顶点。这棵有向树的根结点为 s, 树的每条路径都是有向图中的一条最短路径。</p><p><img data-src="%E4%B8%8B.assets/directed-edge-api.png" alt="加权有向边的 API"></p><p><code>from()</code> 和 <code>to()</code> 方法对于访问边的顶点很有用 。<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvRGlyZWN0ZWRFZGdlLmphdmEuaHRtbA==">DirectedEdge.java</span> 实现了这个 API。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectedEdge</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DirectedEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">double</span> weight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> weight<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/edge-weighted-digraph-api.png" alt="边加权图的 API"></p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvRWRnZVdlaWdodGVkRGlncmFwaC5qYXZhLmh0bWw=">EdgeWeightedDigraph.java</span> 使用邻接列表表示来实现 API。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EdgeWeightedDigraph</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">;</span>                </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">;</span>           </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> adj<span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> indegree<span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">EdgeWeightedDigraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span> <span class="token operator">=</span> <span class="token class-name">V</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>E</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>indegree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        adj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Bag</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        indegree<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span> <span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bag</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">return</span> list<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>EdgeweightedDigraph 类的实现混合了 EdgeweightedGraph 类和 Digraph 类。</p><p><img data-src="https://algs4.cs.princeton.edu/44sp/images/edge-weighted-digraph-representation.png" alt="边加权有向图表示"></p><p>最短路径 API</p><p><img data-src="%E4%B8%8B.assets/sp-api.png" alt="用于 SP 实现的 API"></p><p>最短路径的数据结构。</p><p>最短路径树上的边： edgeTo [v] 是从 s 到 v 的最短路径上的最后一条边。<br>到起点的距离：distTo [v] 是从 s 到 v 的最短路径的长度。</p><p><img data-src="%E4%B8%8B.assets/spt.png" alt="最短路径树"></p><h3 id="松弛"><a class="anchor" href="#松弛">#</a> 松弛</h3><p>我们的最短路径 API 的实现都基于一个被称为松弛 (relaxation) 的简单操作。</p><p>松弛技术，定义如下：放松边 v→w 意味着检查从 s 到 w 的最短路径是否是先从 s 到 v，然后再由 v 到 w。如果是，则根据这个情况更新数据结构的内容。由 v 到达 w 的最短路径是 distTo [v] 与 e.weight () 之和 —— 如果这个值不小于 distTo [w]，称这条边失效了并将它忽略；如果这个值更小，就更新数据。</p><p>边的松弛</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">relax</span><span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span>from<span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> disTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>		distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		edge<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e</pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/relaxation-edge.png" alt="边缘松弛"></p><p>顶点的松弛</p><p>顶点的松弛实现会放松从一个给定顶点指出的所有边。注意，从任意 distTo [v] 为有限值的顶点 v 指向任意 distT [] 为无穷的顶点的边都是有效的。如果 v 被放松，那么这些有效边都会被添加到 edgeTo [] 中。每次顶点松弛操作都能得出到达某个顶点的更短的路径，最后逐渐找出到达每个顶点的最短路径。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">relax</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedDigraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="dijkstra-算法"><a class="anchor" href="#dijkstra-算法">#</a> Dijkstra 算法</h3><p>首先将 distTo [s] 初始化为 0，distTo [] 中的其他元素初始化为正无穷。然后将 distTo [] 最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中或者所有的非树顶点的 distTo [] 值均为无穷大。</p><p>命题 R。Dijkstra 算法能够解决边权重非负的加权有向图的单起点最短路径问题。</p><p>命题 R (续)。在一幅含有 V 个顶点和 E 条边的加权有向图中，使用 Dijkstra 算法计算根结点为给定起点的最短路径树所需的空间与 V 成正比，时间与 ElogV 成正比 (最坏情况下）。</p><p>两种算法都会用添加边的方式构造一棵树：Prim 算法每次添加的都是离树最近的非树顶点，Dijikstra 算法每次添加的都是离起点最近的非树顶点。它们都不需要 marked [] 数组，因为条件！marked [w] 等价于条件 distTo [w] 为无穷大。换句话说，将算法 4.9 中的有向图换成无向图并忽略 relax () 方法中 distTo [v] 部分的代码，就会得到算法 4.7，也就是 Prim 算法的即时版本 (!)</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DijkstraSP</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> distTo<span class="token punctuation">;</span>          </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">DirectedEdge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">IndexMinPQ</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">></span></span> pq<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">DijkstraSP</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedDigraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"edge "</span> <span class="token operator">+</span> e <span class="token operator">+</span> <span class="token string">" has negative weight"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DirectedEdge</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span>POSITIVE_INFINITY<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        </pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// relax vertices in order of distance from s</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexMinPQ</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">int</span> v <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token function">relax</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvRGlqa3N0cmFTUC5qYXZhLmh0bWw=">DijkstraSP.java</span> 是 Dijkstra 算法的有效实现。它使用<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvSW5kZXhNaW5QUS5qYXZhLmh0bWw="> IndexMinPQ.java</span> 作为优先级队列。</p><p><img data-src="%E4%B8%8B.assets/image-20220811222549405.png" alt="image-20220811222549405"></p><p>Dijkstra 算法的实现每次都会为最短路径树添加一条边，该边由一个树中的顶点指向一个非树顶点 w 且它是到 s 最近的顶点。<br>给定两点的最短路径。给定一幅加权有向图以及一个起点 s 和一个终点 t，找到从 s 到 t 的最短路径。以下短小精悍的代码解决了任意顶点对之间的最短路径问题，所需的时间和空间都与 EVlogV 成正比。它构造了 DijkstraSP 对象的数组，每个元素都将相应的顶点作为起点。在用例进行查询时，代码会访问起点所对应的单点最短路径对象并将目的顶点作为参数进行查询。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DijkstraAllpairsSP</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">DijkstraSP</span><span class="token punctuation">[</span><span class="token punctuation">]</span> all</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">DijkstraAllpairsSP</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightDigraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        all <span class="token operator">=</span> ne <span class="token class-name">DijkstraSP</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>            all<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DijkstraSP</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">></span></span> <span class="token function">path</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> all<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span>pathTo<span class="token punctuation">[</span>t<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">double</span> <span class="token function">dist</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">return</span> all<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">distTo</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="无环加权图中的最短路径"><a class="anchor" href="#无环加权图中的最短路径">#</a> 无环加权图中的最短路径</h3><p>许多应用中的加权有向图都是不含有有向环的。我们现在来学习一种比 Dijkstra 算法更快、更简单的在无环加权有向图中找出最短路径的算法。它的特点是:</p><ul><li>它在线性时间内解决了单点最短路径问题。</li><li>它处理负边缘权重。</li><li>它解决了相关问题，例如寻找最长的路径。</li></ul><p><img data-src="%E4%B8%8B.assets/image-20220811224327554.png" alt="image-20220811224327554"></p><p>特别的是，只要将顶点的放松和拓扑排序结合起来，马上就能够得到一种解决无环加权有向图中的最短路径问题的算法。首先，将 distTo [s]. 初始化为 0，其他 distTo・元素初始化为无穷大，然后一个一个地按照拓扑顺序放松所有顶点。</p><p>命题 S。按照拓扑顺序放松顶点，就能在和 E+V 成正比的时间内解决无环加权有向图的单点最短路径问题。</p><p><img data-src="%E4%B8%8B.assets/image-20220811224545206.png" alt="image-20220811224545206"></p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span><span class="token punctuation">,</span> s</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> e <span class="token keyword">of</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">rweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'huaqiu'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">POSITIVE_INFINITY</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">let</span> topological <span class="token operator">=</span> <span class="token function">Topological</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    topological<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>topological<span class="token punctuation">.</span><span class="token function">hasOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'didudidu'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> topological<span class="token punctuation">.</span><span class="token function">rorder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token comment">// console.log(v);</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">adjArr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token function">relax</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>item<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">relax</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">let</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">rweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>      distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">rweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>      edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e</pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">hasPathTo</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">return</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">POSITIVE_INFINITY</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>算法 4.10 的效率几乎已经没有提高的空间了：在拓扑排序后，构造函数会扫描整幅图并将每条边放松一次。在已知加权图是无环的情况下，它是找出最短路径的最好方法。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvQWN5Y2xpY1NQLmphdmEuaHRtbA==">AcyclicSP.java</span> 是这种方法的一个实现。它依赖于这个版本的 <span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvVG9wb2xvZ2ljYWwuamF2YS5odG1s">Topological.java</span>，扩展为支持边加权有向图。</p><p><strong>最长路径</strong>。无环加权有向图中的单点最长路径。</p><p>命题 T。解决无环加权有向图中的最长路径问题所需的时间与 E+V 成正比。</p><p>把图中所有边的权重取反，得到的最短路径即为原图的最长路径，根据这种转换实现 AcyclicLP. 类来寻找一幅无环加权有向图中的最长路径就十分简单了。实现该类的一个更简单的方法是修改 AcycicSP, 将 distTo [] 的初始。值变为 Double.NEGATIVE INFINITY 并改变 relax (方法中的不等式的方向。<span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvQWN5Y2xpY0xQLmphdmEuaHRtbA==">AcyclicLP.java</span> 实现了这种方法。</p><p><strong>并行任务调度</strong>。优先级限制下的并行任务调度。</p><p>— 种叫做 “关键路径 “的方法能够证明这个问题与无环加权有向图中的最长路径问题是等价的。</p><p>定义。解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点 s 和一个终点 t 且每个任务都对应着两个顶点 (一个起始顶点和一个结束顶点)。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每条优先级限制 v→w, 添加一条从 v 的结束顶点指向 w 的起始顶点的权重为零的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token constant">CPM</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">let</span> n <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">let</span> source <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>n</pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">let</span> sink <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>n <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">let</span> <span class="token constant">G</span> <span class="token operator">=</span> <span class="token function">EdgeWeightedDigraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">let</span> duration <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">let</span> e1 <span class="token operator">=</span> <span class="token function">DirectedEdge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">let</span> e2 <span class="token operator">=</span> <span class="token function">DirectedEdge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">let</span> e3 <span class="token operator">=</span> <span class="token function">DirectedEdge</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    e1<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    e2<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>i<span class="token operator">+</span>n<span class="token punctuation">,</span> sink<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    e3<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">+</span>n<span class="token punctuation">,</span> duration<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>e1<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>e3<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> duration<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">let</span> precedent <span class="token operator">=</span> duration<span class="token punctuation">[</span>j<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>duration<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token keyword">let</span> e4 <span class="token operator">=</span> <span class="token function">DirectedEdge</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      e4<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>i<span class="token operator">+</span>n<span class="token punctuation">,</span> precedent<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>e4<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token keyword">let</span> lp <span class="token operator">=</span> <span class="token function">AcyclicLP</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  lp<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">,</span> source<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lp<span class="token punctuation">.</span><span class="token function">rdistTo</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>lp<span class="token punctuation">.</span><span class="token function">rdistTo</span><span class="token punctuation">(</span>sink<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvQ1BNLmphdmEuaHRtbA==">CPM.java</span> 是关键路径方法的实现。</p><p><img data-src="%E4%B8%8B.assets/scheduling-problem.png" alt="作业调度问题"></p><p><img data-src="%E4%B8%8B.assets/scheduling-solution.png" alt="作业调度解决方案"></p><p><img data-src="%E4%B8%8B.assets/image-20220811225315833.png" alt="image-20220811225315833"></p><p>这里实现的任务调度问题的关键路径方法将问题归约为寻找无环加权有向图的最长路径问题。它会根据任务调度问题的描述用关键路径的方法构造一幅加权有向图 (且必然是无环的）)，然后使用 AcyclicLP (请见命题 T) 找到图中的最长路径树，最后打印出各条最长路径的长度，也就正好是每个任务的开始时间。</p><p>命题 U。解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别。</p><p><strong>相对最后期限限制下的并行任务调度</strong>。</p><p>命题 V。相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题 (可能存在环和负权重边)。</p><p>如果任务 V 必须在任务 w 启动后的 d 个时间单位内开始，则添加一条从 v 指向 w 的负权重为 d 的边。</p><p>我们已经学习过的算法都无法完成这个任务：Dijkstra 算法只适用于正 (或零) 权重的边，算法 4.10 要求有向图是无环的。下面我们来看看如何解决含有负权重且不一定是无环的有向图中的最短路径问题。</p><h3 id="一般加权有向图中的最短路径问题"><a class="anchor" href="#一般加权有向图中的最短路径问题">#</a> 一般加权有向图中的最短路径问题</h3><p>接下来，考虑既可能含有环也可能含有负权重的边的加权有向图中的最短路径算法。</p><p>在只存在正权重的边时，我们的重点在于寻找近路；但当存在负权重的边时，我们可能会为了经过负权重的边而绕弯。</p><p>负权重的环。当我们在研究含有负权重边的有向图时，如果该图中含有一个权重为负的环，那么最短路径的概念就失去意义了。</p><p>定义。加权有向图中的负权重环是一个总权重 (环上的所有边的权重之和）为负的有向环。</p><p>命题 W。当且仅当加权有向图中至少存在一条从 s 到 v 的有向路径且所有从 s 到 v 的有向路径上的任意顶点都不存在于任何负权重环中时，S 到 v 的最短路径才是存在的。</p><p><img data-src="%E4%B8%8B.assets/tinyEWDnc.png" alt="an edge-weighted digraph with a negative cycle"></p><p><strong>负权重环的检测</strong>。给定的加权有向图中含有负权重环吗？如果有，找到它。<br><strong>负权重环不可达时的单点最短路径</strong>。给定 -- 幅加权有向图和一个起点 s 且从 s 无法到达任何负</p><p>总结。尽管在含有环的有向图中最短路径是一个没有意义的问题，而且也无法有效解决在这种有向图中高效找出最短简单路径的问题，在实际应用中仍然需要能够识别其中的负权重环。限制条件和最后期限都是从现实世界中的实际限制得来的，因此负权重环大多可能来自于问题陈述中的错误。找出负权重环，改正相应的错误，找到没有负权重环问题的调度方案才是解决问题的正确方式。</p><p>命题 X（Bellman-Ford 算法）。在任意含有 V 个顶点的加权有向图中给定起点 s, 从 s 无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将 distTo [s] 初始化为 0，其他 distTo [] 元素初始化为无穷大。以任意顺序放松有向图的所有边，重复 V 轮。</p><p>命题 W (续）。Bellman-Ford 算法所需的时间和 EV 成正比，空间和 V 成正比。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> pass <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pass <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pass<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>          <span class="token function">relax</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>基于队列的 Bellman-Ford</strong>。</p><p><img data-src="%E4%B8%8B.assets/image-20220812085220916.png" alt="image-20220812085220916"></p><p>命题 Y。对于任意含有 V 个顶点的加权有向图和给定的起点 s, 在最坏情况下基于队列的 Bellman-Ford 算法解决最短路径问题 (或者找到从 s 可达的负权重环) 所需的时间与 EV 成正比，空间和 V 成正比。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span><span class="token punctuation">,</span> s</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    onQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">POSITIVE_INFINITY</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    onQueue<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasNegativeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">let</span> v <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      onQueue<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token function">relax</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">relax</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">G</span><span class="token punctuation">,</span> v</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">adjArr</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token keyword">let</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span>item<span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">></span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>item<span class="token punctuation">.</span><span class="token function">rweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">EPSILON</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>item<span class="token punctuation">.</span><span class="token function">rweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>item</pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onQueue<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>          queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>          onQueue<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>cost <span class="token operator">%</span> <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">VSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token function">findNegativeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">hasNegativeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span></pre></td></tr><tr><td data-num="33"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>基于队列的 Bellman-Ford 算法能够准确有效地解决最短路径问题并且在实际中被广泛应用，甚至包括正权重的情况。</p><p><span class="exturl" data-url="aHR0cHM6Ly9hbGdzNC5jcy5wcmluY2V0b24uZWR1LzQ0c3AvQmVsbG1hbkZvcmRTUC5qYXZhLmh0bWw=">BellmanFordSP.java</span> 通过维护两个额外的数据结构来实现这种方法：要放松的顶点队列<br>一个顶点索引布尔数组 onQ []，指示哪些顶点在队列中，以避免重复。</p><p><strong>负权重环检测</strong>。</p><p><img data-src="%E4%B8%8B.assets/negative-cycle-api.png" alt="负循环检测API"></p><p>这种方法能够保证构造函数中的循环必然会终止。另外，用例可以调用 hasNegativeCycle () 来判断是否存在从起点可达的负权重环 (并用 negativeCycle () 来获取这个环)。</p><p><img data-src="%E4%B8%8B.assets/image-20220812091136637.png" alt="image-20220812091136637"></p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">findNegativeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">let</span> <span class="token constant">V</span> <span class="token operator">=</span> edgeTo<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">let</span> spt <span class="token operator">=</span> <span class="token function">EdgeWeightedDigraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    spt<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">V</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token constant">V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>edgeTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        spt<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>edgeTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">let</span> finder <span class="token operator">=</span> <span class="token function">EdgeWeightedDirectedCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    finder<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>spt<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cycle <span class="token operator">=</span> finder<span class="token punctuation">.</span><span class="token function">rcycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220812091245468.png" alt="image-20220812091245468"></p><p>头两轮放松操作与处理 tinyEWDn.・txt 时是一样的。在第三轮中，算法在放松了边 7→3 和 5→1 并将顶点 3 和 1 加入队列后开始放松负权重边 5→4。在这次放松操作中算法发现了一个负权重环 4→5→4。它将 5→4 加入最短路径树中并在 edgeTo [] 中将环和起点隔离开来。从这时开始，算法沿着环继续运行并会减少到达所遇到的所有顶点的距离，直至检测到环的存在，. 此时队列非空。环被保存在 edgeTo [] 中，findNegativecycle () 会在其中找到它。</p><p><strong>套汇</strong>。</p><p>这张表格等价于一副完全的加权有向图</p><p><img data-src="%E4%B8%8B.assets/rates.png" alt="汇率"></p><p>命题 Z。套汇问题等价于加权有向图中的负权重环的检测问题。</p><p>图中的任意负权重环都是一次套汇的好机会</p><p><img data-src="%E4%B8%8B.assets/arbitrage.png" alt="套利机会"></p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">Arbitrage</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">let</span> <span class="token constant">V</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">V</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">let</span> <span class="token constant">G</span> <span class="token operator">=</span> <span class="token function">EdgeWeightedDigraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">V</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token constant">V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    name<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> w <span class="token operator">&lt;</span> <span class="token constant">V</span><span class="token punctuation">;</span> w<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">let</span> rate <span class="token operator">=</span> arr<span class="token punctuation">[</span>v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token keyword">let</span> e <span class="token operator">=</span> <span class="token function">DirectedEdge</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      e<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">,</span> <span class="token operator">-</span>Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rate<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token constant">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">let</span> spt <span class="token operator">=</span> <span class="token function">BellmanFordSP</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>  spt<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token constant">G</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>spt<span class="token punctuation">.</span><span class="token function">hasNegativeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">let</span> stake <span class="token operator">=</span> <span class="token number">1000</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">let</span> cycle <span class="token operator">=</span> spt<span class="token punctuation">.</span><span class="token function">negativeCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token operator">!</span>cycle<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token keyword">let</span> e <span class="token operator">=</span> cycle<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stake<span class="token punctuation">,</span> name<span class="token punctuation">[</span>e<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      stake <span class="token operator">*=</span> Math<span class="token punctuation">.</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>e<span class="token punctuation">.</span><span class="token function">rweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stake<span class="token punctuation">,</span> name<span class="token punctuation">[</span>e<span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ji'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="5-字符串strings"><a class="anchor" href="#5-字符串strings">#</a> 5. 字符串 (Strings)</h1><h2 id="51-字符串排序string-sorts"><a class="anchor" href="#51-字符串排序string-sorts">#</a> 5.1 字符串排序 (String Sorts)</h2><p>对于许多排序应用，决定顺序的键都是字符串。本节中，我们将会考察能够利用字符串的特殊性质将字符串键排序的方法，它们将比第 2 章学过的通用排序方法效率更高。</p><p>不可变性。String 对象是不可变的。索引，charAt ()。子字符串，substring ()。字符串的连接，使用 “+” 运算符，所需的时间与结果字符串的长度成正比。我们会避免将字符一个一个地追加到字符串中，因为在 Java 里这个过程所需的时间将会是平方级别的.</p><p>对于许多排序应用，决定顺序的键都是字符串。本节中，我们将会考察能够利用字符串的特殊性质将字符串键排序的方法，它们将比第 2 章学过的通用排序方法效率更高。</p><p>第一类方法会从右到左检查键中的字符。这种方法一般被称为低位优先 (LSD) 的字符串排序。使用数字 (digit) 代替字符 ( character ) 的原因要追溯到相同方法在各种数字类型中的应用。这种方法最适合用于键的长度都相同的字符串排序应用。<br>第二类方法会从左到右检查键中的字符，首先查看的是最高位的字符。这些方法通常称为高位优先 (MSD) 的字符串排序 —— 本节将会学习两种此类算法。(高位优先的字符串排序的吸引人之处在于，它们不一定需要检查所有的输入就能够完成排序。高位优先的字符串排序和快速排序类似，因为它们都会将需要排序的数组切分为独立的部分并递归地用相同的方法处理子数组来完成排序。它们的区别之处在于高位优先的字符串排序算法在切分时仅使用键的第一个字符，而快速排序的比较则会涉及键的全部。要学习的第一种方法会将相同字符的键划入同一个切分，第二种方法则总会产生三个切分，分别对应被搜索键的第一个字符小于、等于或大于切分键的第一个字符的情况。)</p><h3 id="字母表"><a class="anchor" href="#字母表">#</a> 字母表</h3><p><img data-src="%E4%B8%8B.assets/image-20220814145153003.png" alt="image-20220814145153003"></p><p><img data-src="%E4%B8%8B.assets/image-20220814145208460.png" alt="image-20220814145208460"></p><pre><code>
</code></pre><h3 id="键索引计数法"><a class="anchor" href="#键索引计数法">#</a> 键索引计数法</h3><p>作为热身，我们先学习一种适用于小整数键的简单排序方法。这种叫做键索引计数的方法本身就很实用，同时也是本节中将要学习的两三种字符串排序算法的基础。</p><p>1. 频率统计。第一步就是使用 int 数组 count [] 计算每个键出现的频率。对于数组中的每个元素，都使用它的键访问 count [] 中的相应元素并将其加 1。如果键为 r, 则将 count [r+1] 加 1。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>	count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220814150617929.png" alt="image-20220814150617929"></p><p>2. 将频率转换为索引。接下来，我们会使用 count [] 来计算每个键在排序结果中的起始索引位置。在这个示例中，因为第一组中有 3 个人，第二组中有 5 个人，因此第三组中的同学在排序结果数组中的起始位置为 8。一般来说，任意给定的键的起始索引均为所有较小的键所对应的出现频率之和。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>int r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>    count<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>r<span class="token punctuation">]</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220814150724691.png" alt="image-20220814150724691"></p><p>3. 数据分类。</p><p>在将 count [] 数组转换为一张索引表之后，将所有元素（学生）移动到一个辅助数组 aux [] 中以进行排序。每个元素在 aux [] 中的位置是由它的键（组别) 对应的 count [] 值决定，在移动之后将 count [] 中对应元素的值加 1，以保证 count [r] 总是下一个键为 r 的元素在 aux [] 中的索引位置。这个过程只需遍历一遍数据即可产生排序结果，如图 5.1.4 所示。注意：在我们的一个应用中，这种实现方式的稳定性是很关键的 —— 键相同的元素在排序后会被聚集到一起，但相对顺序没有变化.</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>	aux<span class="token punctuation">[</span>count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220814151153012.png" alt="image-20220814151153012"></p><p>4. 回写。因为我们在将元素移动到辅助数组的过程中完成了排序，所以最后一步就是将排序的结果复制。回原数组中。</p><p>命题 A。键索引计数法排序 N 个键为 0 到 R-1 之间的整数的元素需要访问数组 11N+4R+1 次。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> a<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 计算出现频率</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>	count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 将频率转换为索引</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token class-name">R</span><span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    count<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>r<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 将元素分类</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>	aux<span class="token punctuation">[</span>count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment">// 回写</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr></table></figure><h3 id="低位优先的字符串排序lsd"><a class="anchor" href="#低位优先的字符串排序lsd">#</a> 低位优先的字符串排序 (LSD)</h3><p>这些字符串的长度都是相同的。这种情况在排序应用中很常见 —— 比如电话号码、银行账号、IP 地址等都是典型的定长字符串。<br>将此类字符串排序可以通过键索引计数法来完成，如果字符串的长度均为 W, 那就从右向左以每个位置的字符作为键，用键索引计数法将字符串排序 W 遍。事实上，除非键索引计数法是稳定的，否则这种方法是行不通的。</p><p>命题 B。低位优先的字符串排序算法能够稳定地将定长字符串排序。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> w</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">let</span> n <span class="token operator">=</span> a<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">let</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token number">256</span> <span class="token comment">// extend ASCII alphabet size</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">let</span> aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> d <span class="token operator">=</span> w <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> d <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> d<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token comment">// 键索引计数法</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">R</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token comment">// 计数频率</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token comment">//count 数组计数 ASCII 每个字符出现次数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        count<span class="token punctuation">[</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token comment">// 频率转换为索引</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        count<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>r<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token comment">// 数据分类</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token comment">// 把第 i 个放到 count 数组中的索引值的位置</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token comment">// 在移动之后将 count [] 中对应元素的值加 1，以保证 count [r] 总是下一个键为 r 的元素在 aux [] 中的索引位置</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        aux<span class="token punctuation">[</span>count<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token comment">// 回写</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="26"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sort'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">return</span> a</pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220814151759231.png" alt="image-20220814151759231"></p><p>从理论上说，低位优先的字符串排序的意义重大，因为它是一种适用于一般应用的线性时间排序算法。无论 N 有多大，它都只遍历 w 次数据。具体描述如下。</p><p>命题 B (续)。对于基于 R 个字符的字母表的 N 个以长为 W 的字符串为键的元素，低位优先的字符串排序需要访问～7WN + 3WR 次数组，使用的额外空间与 N＋R 成正比。</p><h3 id="高位优先的字符串排序msd"><a class="anchor" href="#高位优先的字符串排序msd">#</a> 高位优先的字符串排序 (MSD)</h3><p>要实现一个通用的字符串排序算法 (字符串的长度不一定相同)，我们应该考虑从左向右遍历所有字符。我们知道，以 a 开头的字符串应该排在以 b 开头的字符串前面，等等。实现这种思想的一个很自然方法就是一种递归算法，被称为高位优先 (MSD) 的字符串排序，请见图 5.1.8。<strong>首先用键索引计数法将所有字符串按照首字母排序，然后 (递归地）再将每个首字母所对应的子数组排序</strong>（忽略首字母，因为每一类中的所有字符串的首字母都是相同的)。(和快速排序一样，高位优先的字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组，而不是像快速排序中那样产生固定的两个或三个切分)</p><p>在高位优先的字符串排序算法中，要特别注意到达字符串末尾的情况。在排序中，合理的做法是将所有字符都已被检查过的字符串所在的子数组排在所有子数组的前面，这样就不需要递归地将该子数组排序。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">const</span> <span class="token constant">CUTOFF</span> <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">,</span> d<span class="token punctuation">,</span> aux</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">let</span> n <span class="token operator">=</span> a<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">let</span> aux <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> aux<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token keyword">return</span> a</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 小数组用插入排序</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo <span class="token operator">+</span> <span class="token constant">CUTOFF</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token function">insertion</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token keyword">return</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 键索引计数法</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">R</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> lo<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">charAt</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      count<span class="token punctuation">[</span>c <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">++</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token constant">R</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      count<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>r<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> lo<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token function">charAt</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>      aux<span class="token punctuation">[</span>count<span class="token punctuation">[</span>c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> lo<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> hi<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>      a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> aux<span class="token punctuation">[</span>i <span class="token operator">-</span> lo<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token comment">// 循环处理后面字母</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>      <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo <span class="token operator">+</span> count<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> lo <span class="token operator">+</span> count<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> aux<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token comment">// 返回 s 的第 d 字符，如果 d = s 的长度返回 - 1</span></pre></td></tr><tr><td data-num="37"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> s<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220814153301230.png" alt="image-20220814153301230"></p><ul><li>小型子数组。这种方法能够快速地将需要排序的数组切分为较小的数组。但这种切分也是一 - 把双刃剑：我们肯定会需要处理大量微型数组，因此必须快速处理它们。小型子数组对于高位优先的字符串排序的性能至关重要。将小数组切换到插入排序对于高位优先的字符串排序算法是必须的。</li><li>等值键。高位优先的字符串排序的最坏情况就是所有的键均相同。大量含有相同前缀的键也会产生。同样的问题，这在一般的应用场景中是很常见的。</li><li>额外空间。如果牺牲稳定性，则可以去掉 aux [] 数组，但它并不是高位优先的字符串排序算法在实际应用中所关注的内容。相反，count [] 所需的空间才是主要问题 (因为它不能在递归方法 sort () 之外创建)</li></ul><p>命题 C。要将基于大小为 R 的字母表的 N 个字符串排序，高位优先的字符串排序算法平均需要检查 Nog,N 个字符。</p><p>命题 D。要将基于大小为 R 的字母表的 N 个字符串排序，高位优先的字符串排序算法访问数组的次数在 8N+3R 到 7wN+3wR 之间，其中 w 是字符串的平均长度。</p><p>命题 D (续)。要将基于大小为 R 的字母表的 N 个字符串排序，最坏情况下高位优先的字符串排序算法所需的空间与 R 乘以最长的字符串的长度之积成正比 (再加上 N).</p><h3 id="三向字符串快速排序"><a class="anchor" href="#三向字符串快速排序">#</a> 三向字符串快速排序</h3><p>对于字符串的排序，这个方法比普通的快速排序和高位优先的字符串排序更友好。实际上，它就是这两种算法的结合。</p><p>高位优先的字符串排序可能会创建大量 (空）子数组，而三向字符串快速排序的切分总是只有三个。因此三向字符串快速排序能够很好处理等值键、有较长公共前缀的键、取值范围较小的键和小数组 —— 所有高位优先的字符串排序算法不善长的各种情况。特别重要的一点是，这种切分方法能够适应键的不同部分的不同结构。和快速排序一样，三向字符串快速。排序也不需要额外的空间 (递归所需的隐式栈除外), 这是它相比高位优先的字符串排序的一大优点，后者在统计频率和使用辅助数组时都需要空间。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token constant">CUTOFF</span> <span class="token operator">=</span> <span class="token number">10</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">return</span> a</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 小数组使用插入排序</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo <span class="token operator">+</span> <span class="token constant">CUTOFF</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token function">insertion</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">return</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 三向切分</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">let</span> lt <span class="token operator">=</span> lo<span class="token punctuation">,</span> gt <span class="token operator">=</span> hi</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">charAt</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">let</span> i <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> gt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">charAt</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> v<span class="token punctuation">)</span> <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lt<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> v<span class="token punctuation">)</span> <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> gt<span class="token operator">--</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">else</span> i<span class="token operator">++</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 递归</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> lt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lt<span class="token punctuation">,</span> gt<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> gt <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E4%B8%8B.assets/image-20220814153228670.png" alt="image-20220814153228670"></p><p>命题 E。要将含有 N 个随机字符串的数组排序，三向字符串快速排序平均需要比较字符～2NInN 次。</p><h2 id="52-单词查找树tier"><a class="anchor" href="#52-单词查找树tier">#</a> 5.2 单词查找树 (tier)</h2><p>本节中所讨论的算法在一般应用场景中 (甚至对于巨型的符号表）都能够取得以下性能:</p><ul><li>查找命中所需的时间与被查找的键的长度成正比；</li><li>找未命中只需检查若干个字符。</li></ul><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220815223852289.png" alt="image-20220815223852289"></p><h3 id="单词查找树"><a class="anchor" href="#单词查找树">#</a> 单词查找树</h3><p>值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树中的查找操作。</p><p>** 查找操作。** 不仅要找到键还要有值。</p><ul><li>键的尾字符所对应的结点中的值非空。这是一次命中的查找 —— 键所对应的值就是键的尾字符所对应的结点中保存的值。</li><li>键的尾字符所对应的结点中的值为空。这是一次未命中的查找 —— 符号表中不存在被查找的键。</li><li>查找结束于一条空链接。这也是一次未命中的查找。</li></ul><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220815224206135.png" alt="image-20220815224206135"></p><p><strong>插入操作</strong>。添加和替换</p><ul><li><p>在到达键的尾字符之前就遇到了一个空链接。在这种情况下，字符查找树中不存在与键的尾字符对应的结点，因此需要为键中还未被检查的每个字符创建一个对应的结点并将键的值保存到最后一个字符的结点中。</p></li><li><p>在遇到空链接之前就到达了键的尾字符。在这种情况下，和关联性数组一样，将该结点的值设为键所对应的值 (无论该值是否为空)。</p></li></ul><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220815224638596.png" alt="image-20220815224638596"></p><p>数据结构不会存储任何字符串或字符，它保存了链接数组和值。因为参数 R 的作用的重要性，所以将基于含有 R 个字符的字母表的单词查找树称为 R 向单词查找树。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'didudidu'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">return</span> node<span class="token punctuation">.</span>val</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> key<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 沿着每个字母的 ascii 码向下查 </span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">let</span> c <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token function">deleteKey</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">else</span> root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token keyword">return</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 没有就添加</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// 查完了就返回</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> key<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> n<span class="token operator">++</span></pre></td></tr><tr><td data-num="26"></td><td><pre>      x<span class="token punctuation">.</span>val <span class="token operator">=</span> val</pre></td></tr><tr><td data-num="27"></td><td><pre>      <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// 沿着 c 向下查</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">let</span> c <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="33"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>** 查找所有键。** 每当我们在 collect () 调用中访问一个结点时，方法的第一个参数就是该结点，第二个参数则是和该结点相关联的字符串（从根结点到该结点的路径上的所有字符)。在访问一个结点时，如果它的值非空，我们就将和它相关联的字符串加入队列之中，然后（递归地）访问它的链接数组所指向的所有可能的字符结点。在每次调用之前，都将链接对应的字符附加到当前键的末尾作为调用的参数键。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">keysWithPrefix</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 前缀匹配</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">keysWithPrefix</span><span class="token punctuation">(</span><span class="token parameter">prefix</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 找到参数前缀的位置 然后在遍历前缀的所有可能</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 再把前缀传进去拼接</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">collect</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">,</span> results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> results</pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token comment">// 遍历 x 的所有子节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">collect</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> results</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>val<span class="token punctuation">)</span> results<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 在 x 的所有 (R 个) 方向中寻找</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 遍历 x 的所有子节点</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      prefix<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token function">collect</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      prefix<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220816094540028.png" alt="image-20220816094540028"></p><p><strong>通配符匹配</strong>。如果模式中含有通配符，就需要用递归调用处理所有的链接，否则就只需要处理模式中指定字符的链接即可。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 通配符匹配</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">keysThatMatch</span><span class="token punctuation">(</span><span class="token parameter">pattern</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">collect1</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> results</pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">collect1</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> results</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">let</span> d <span class="token operator">=</span> prefix<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> pattern<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> x<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      results<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">let</span> c <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 如果是通配符就遍历所有方向</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> ch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> ch <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> ch<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        prefix<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">collect1</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        prefix<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 否则就递归 c 这个方向</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      prefix<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token function">collect1</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> results<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>      prefix<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220816095013734.png" alt="image-20220816095013734"></p><p>** 最长前缀。** 为了找到给定字符串的最长键前缀，就需要使用一个类似于 get () 的递归方法。它会记录查找路径上所找到的最长键的长度（将它作为递归方法的参数在遇到值非空的结点时更新它)。查找会在被查找的字符串结束或是遇到空链接时终止。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 最长前缀</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">longestPrefixOf</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> query<span class="token punctuation">,</span> d<span class="token punctuation">,</span> length</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>query<span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">let</span> length <span class="token operator">=</span> <span class="token function">longestPrefixOf</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">else</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> length</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>val <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> length <span class="token operator">=</span> d</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> query<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> length</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 沿着前缀找 找到最长然后截取前缀</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">let</span> c <span class="token operator">=</span> query<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">longestPrefixOf</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> query<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220816095517609.png" alt="image-20220816095517609"></p><p>** 删除操作。** 从一棵单词查找树中删去一个键值对的第一步是，找到键所对应的结点并将它的值设为空。如果该结点含有一个非空的链接指向某个子结点，那么就不需要在进行其他操作了。如果它的所有链接均为空，那就需要从数据结构中删去这个结点。如果删去它使得它的父结点的所有链接也均为空，就需要继续删除它的父结点，依此类推。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">deleteKey</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      root <span class="token operator">=</span> <span class="token function">deleteKey</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">return</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 如果找到了 存在就树大小减一并设空</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">==</span> key<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>val<span class="token punctuation">)</span> n<span class="token operator">--</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      x<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token comment">// 接着向 c 方向找</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token keyword">let</span> c <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deleteKey</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>next<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220816095805950.png" alt="image-20220816095805950"></p><h3 id="性质"><a class="anchor" href="#性质">#</a> 性质</h3><p>命题 F。单词查找树的链表结构 (形状) 和键的插入或删除顺序无关：对于任意给定的一组键，其单词查找树都是唯一的。</p><p>命题 G。在单词查找树中查找一个键或是插入一个键时，访问数组的次数最多的键的长度加 1。</p><p>命题 H。字母表的大小为 R, 在一棵由 N 个随机键构造的单词查找树中，未命中查找平均所需检查的结点数量为～logRN。</p><p>命题 I。一棵单词查找树中的链接总数在 RN 到 RNw 之间，其中 w 为键的平均长度。</p><p>我们的底线是：不要使用算法 5.4 处理来自于大型字母表的大量长键。</p><h3 id="三向单词查找树"><a class="anchor" href="#三向单词查找树">#</a> 三向单词查找树</h3><p>为了避免 R 向单词查找树过度的空间消耗，我们现在来学习另一种数据的表示方法：三向单词查找树 (TST)。** 在三向单词查找树中，每个结点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于结点字母的所有键。** 在算法 5.4 的 R 向单词查找树中，树的结点含有 R 条链接，每个非空链接的索引隐式地表示了它所对应的字符。在等价的三向单词查找树中，字符是显式地保存在结点中的 -— 只有在沿着中间链接前进时才会根据字符找到表中的键</p><p>** 查找和插入操作。** 用三向单词查找树实现符号表 API 中的查找和插入操作很简单。在查找时，我们首先比较键的首字母和根结点的字母。如果键的首字母较小，就选择左链接；如果较大，就选择右链接；如果相等，则选择中链接。然后，递归地使用相同的算法。如果遇到了 - 一个空链接或者当键结束时结点的值为空，那么查找未命中；如果键结束时结点的值非空则查找命中。在插入一个新键时，首先进行查找，然后和在单词查找树一样，在树中补全键末尾的所有结点。算法 5.5 给出了这些方法的实现细节。</p><p>我们可以发现三向单词查找树与三向字符串快速排序之间的对应关系与二叉查找树与快速排序以及单词查找树与高位优先的排序之间的对应关系是一样的。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">return</span> node<span class="token punctuation">.</span>val</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 拿单词的第一个字母进行比较递归</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">let</span> c <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> x<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 找到就找下一个字母</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> key<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>mid<span class="token punctuation">,</span> key<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'ddd'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">contains</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> n<span class="token operator">++</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> n<span class="token operator">--</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token keyword">return</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token comment">// 拿单词的第一个字母进行比较递归</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">let</span> c <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// 如果不存在就新建一个结点</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>      x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>      x<span class="token punctuation">.</span>c <span class="token operator">=</span> c</pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>c<span class="token punctuation">)</span> x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> x<span class="token punctuation">.</span>c<span class="token punctuation">)</span> x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> d<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">// 找到就找下一个字母</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">&lt;</span> key<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> x<span class="token punctuation">.</span>mid <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>mid<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token comment">// 设置值</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">else</span> x<span class="token punctuation">.</span>val <span class="token operator">=</span> val</pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token keyword">return</span> x</pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220816102737218.png" alt="image-20220816102737218"></p><h3 id="三向单词查找树性质"><a class="anchor" href="#三向单词查找树性质">#</a> 三向单词查找树性质</h3><p>三向单词查找树是 R 向单词查找树的紧凑表示，但两种数据结构的性质截然不同。这其中最重要的不同可能在于命题 A 对于三向单词查找树不再成立：和其他所有二叉查找树一样，每个单词查找树结点的二叉查找树表示也取决于键的插入顺序。</p><p><strong>空间</strong>。三向单词查找树最重要的性质就是每个结点只含有三个链接，因此三向单词查找树所需要空间远小于对应的单词查找树。</p><p>命题 J。由 N 个平均长度为 w 的字符串构造的三向单词查找树中的链接总数在 3N 到 3Nw 之间。</p><p>命题 K。在一棵由 N 个随机字符串构造的三向单词查找树中，查找未命中平均需要比较字符～InN 次。除～InN 次外，一次插入或命中的查找会比较一次被查找的键中的每个字符。</p><p><strong>混合三向单词查找树</strong>。简单改进一下基于三向单词查找树的查找方式：使用一个大型显式的多向根结点。实现它最简单的办法就是维护一张含有 R 棵三向单词查找树的表:・每一棵都对应着键的首字母的一种可能的值。如果 R 不大，那可以使用键的头两个字母 (表的大小变为 R<sup>2</sup> )。这种方法有效的前提是键的首字母的分布必须均匀。这样得到的混合查找算法和人们在电话黄页中查找姓名的行为很相似。查找的第一步是进行多向判断 (“让我们来看看，它的首字母是‘A’”)，接下来可能是某种双向判断 (“它在‘Andrews’之前，但在‘Aitken’之后”)，然后就是一系列字符匹配 (“‘Algonquin',…… 没有，‘Algorithms’不在列表之中，因为没有以‘Algor’开头的单词！”)。这些程序可能是查找字符串类型的键的最快算法。</p><p>命题 L。由 N 个随机字符串构造的根结点进行了 R<sup>t</sup>向分支且不含有外部单向分支的三向单词查找树中，一次插入或查找操作平均需要进行约 InN-tInR 次字符比较。</p><h3 id="应该使用字符串符号表的哪种实现"><a class="anchor" href="#应该使用字符串符号表的哪种实现">#</a> 应该使用字符串符号表的哪种实现</h3><p>如果空间足够，R 向单词查找树的速度是最快的，能够在常数次字符比较内完成查找。对于大型字母表，R 向单词查找树所需的空间可能无法满足时，三向单词查找树是最佳的选择，因为它对 “字符” 比较次数是对数级别的比较，而二叉查找树中键的比较次数是对数级别的。散列表也是很有竞争力的，但如前文所述，它不支持有序性的符号表操作，也不支持扩展的字符类 API 操作，例如前缀或通配符匹配。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220816103524150.png" alt="image-20220816103524150"></p><h2 id="53-子字符串搜索substring-search"><a class="anchor" href="#53-子字符串搜索substring-search">#</a> 5.3 子字符串搜索 (Substring Search)</h2><p>字符串的一种基本操作就是子字符串查找：给定一段长度为 N 的文本和一个长度为 M 的 (pattern) 模式字符串，在文本中找到一个和该模式相符的子字符串。解决该问题的大部分算法都可以很容易地扩展为找出文本中所有和该模式相符的子字符串、统计该模式在文本中的出现次数、或者找出上下文 (和该模式相符的子字符串周围的文字) 的算法。</p><p>Knuth-Morris-Pratt 算法和 Boyer-Moore 算法都需要对模式字符串进行复杂的预处理，这个过程十分晦涩而且也限制了它们的应用范围。(事实上，有位系统程序员觉得 Morris 算法实在是太难懂了，就干脆用暴力算法代替了。)<br>在 1980 年，M.O.Rabin 和 R.M.Karp 使用散列开发出了一种与暴力算法几乎一样简单但运行时 - 间与 M+N 成正比的概率极高的算法。另外，它们的算法还可以扩展到二维的模式和文本中，这使得它比其他算法更适用于图像处理。</p><h3 id="暴力子字符串查找算法"><a class="anchor" href="#暴力子字符串查找算法">#</a> 暴力子字符串查找算法</h3><p>这段程序使用了一个指针 i 跟踪文本，一个指针 j 跟踪模式。对于每个 i，代码首先将 j 重置为 0 并不断将它增大，直至找到了一个不匹配的字符或是模式结束 (j==M) 为止。如果在模式字符串结束之前文本字符串就已经结束了 (i==N-M+1), 那么就没有找到匹配：模式字符串在文本中不存在。我们约定在不匹配时返回 N 的值。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">search1</span><span class="token punctuation">(</span><span class="token parameter">pat<span class="token punctuation">,</span> txt</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">let</span> m <span class="token operator">=</span> pat<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">let</span> n <span class="token operator">=</span> txt<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">let</span> j</pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">!=</span> pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> i <span class="token comment">// 找到</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> n <span class="token comment">// 没找到</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>命题 M。在最坏情况下，暴力子字符串查找算法在长度为 N 的文本中查找长度为 M 的模式需要～NM 次字符比较.</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817162801791.png" alt="image-20220817162801791"></p><p>下方框注所示的该算法的另一种实现是有指导意义的。和以前一样，程序使用了一个指针 i 跟踪文本，一个指针 j 跟踪模式。在 i 和 j 指向的字符相匹配时，代码进行的字符比较和上一个实现相同。请注意，这段代码中的 i 值相当于上一段代码中的 i+j : 它指向的是文本中已经匹配过的字符序列的末端 ( i 以前指向的是这个序列的开头）。如果 i 和 j 指向的字符不匹配了，那么需要回退这两个指针的值：将 j 重新指向模式的开头，将 i 指向本次匹配的开始位置的下一个字符。</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">search2</span><span class="token punctuation">(</span><span class="token parameter">pat<span class="token punctuation">,</span> txt</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">let</span> m <span class="token operator">=</span> pat<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">let</span> n <span class="token operator">=</span> txt<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">let</span> i<span class="token punctuation">,</span> j</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> o<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> j<span class="token operator">++</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        i <span class="token operator">-=</span> j</pre></td></tr><tr><td data-num="9"></td><td><pre>        j <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> i <span class="token operator">-</span> m <span class="token comment">// 找到</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">else</span> <span class="token keyword">return</span> n <span class="token comment">// 没找到</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="knuth-morris-pratt子字符串查找算法"><a class="anchor" href="#knuth-morris-pratt子字符串查找算法">#</a> Knuth-Morris-Pratt 子字符串查找算法</h3><p>这里不需要回退文本指针 i 。这说明，对于这个模式，可以将暴力子字符串查找算法实现中的 else 语句替换为 j =1 (且并不将 i 加 1)。令人惊讶的是，在匹配失败时总是能够将 j 设为某个值以使 i 不回退。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817173355666.png" alt="image-20220817173355666"></p><p>** 在匹配失败时，如果模式字符串中的某处可以和匹配失败处的正文相匹配，那么就不应该完全跳过所有已经匹配的所有字符。**KMP 算法的主要思想是提前判断如何重新开始查找，而这种判断只取决于模式本身。</p><p><strong>模式指针的回退</strong>。** 在 KMP 子字符串查找算法中，不会回退文本指针 i ，而是使用一个数组 dfa [][] 来记录匹配失败时模式指针 j 应该回退多远。** 对于每个字符 c , 在比较了 c 和 pat.charAt (j) 之后，**dfa [c][j] 表示的是应该和下个文本字符比较的模式字符的位置。** 对于每个字符 c，你可以将这个过程想象为首先将模式字符串的一个副本覆盖在这 j 个字符之上。然后从左向右滑动这个副本直到所有重叠的字符都相互匹配 (或者没有相匹配的字符) 时才停下来。<strong>滑盖。</strong></p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817175526221.png" alt="image-20220817175526221"></p><p>**KMP 查找算法。** 当 i 和 j 所指向的字符匹配失败时，无需回退指针 i ，只需要将 j 设为 dfa [txt.charAt (i)][j] 并将 i 加 1 即。</p><p>**DFA 模拟。** 确定有限状态自动机 (DFA), 确定有限状态自动机是由状态 (数字标记的圆圈) 和转换 (带标签的箭头) 组成的。模式中的每个字符都对应着一个状态，每个此类状态能够转换为字母表中的任意字符。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817175848560.png" alt="image-20220817175848560"></p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817180003637.png" alt="image-20220817180003637"></p><p>每次匹配都会将 DFA 带向下一个状态（等价于增大模式字符串的指针 j ); 每次匹配失败都会使 DFA 回到较早前的状态 (等价于将模式字符串的指针 j 变为一个较小的值)。j 就是状态码。</p><p><strong>构造 DFA</strong>。这里的关键在于需要重新扫描的文本字符正是 pat.charAt (1) 到 pat.charAt (j-1) 之间，忽略了首字母是因为模式需要右移一位，忽略了最后一个字符是因为匹配失败。</p><p>下面这段短小精悍的代码来构造给定模式的 DFA 。对于每个 j，它将会:</p><ul><li>将 dfa [][X] 复制到 dfa [][j](对于匹配失败的情况);</li><li>将 dfa [pat.charAt (j)][j] 设为 j +1 (对于匹配成功的情况）;</li><li>更新 X。</li></ul><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>dfa<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">X</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token class-name">R</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">// 计算 dfa [][]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>let c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token class-name">R</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		dfa<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dfa<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">X</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	dfa<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	</pre></td></tr><tr><td data-num="8"></td><td><pre>	x <span class="token operator">=</span> dfa<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">X</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token parameter">pat</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">R</span> <span class="token operator">=</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    m <span class="token operator">=</span> pat<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="4"></td><td><pre>    dfa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    dfa<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        dfa<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dfa<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      dfa<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      x <span class="token operator">=</span> dfa<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">let</span> n <span class="token operator">=</span> txt<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">let</span> i<span class="token punctuation">,</span> j</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">&amp;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      j <span class="token operator">=</span> dfa<span class="token punctuation">[</span>txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> i <span class="token operator">-</span> m</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> n</pre></td></tr><tr><td data-num="20"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>命题 N, 对于长度为 M 的模式字符串和长度为 N 的文本，Knuth-Morris-Pratt 字符串查找算法访问的字符不会超过 M+N 个。</p><h3 id="boyer-moore字符串查找算法"><a class="anchor" href="#boyer-moore字符串查找算法">#</a> Boyer-Moore 字符串查找算法</h3><p>当可以在文本字符串中回退时，如果可以从右向左扫描模式字符串并将它和文本匹配，那么就能得到一种非常快的字符串查找算法。例如，在查找子字符串 BAABBAA 时，如果匹配了第七个和第六个字符，但在第 5 个字符处匹配失败，那马上就可以将模式向右移动 7 个位置并继续检查文本中的第 14 个字符。</p><p>** 起点。** 我们使用数组 right [] 记录字母表中的每个字符在模式中出现的最靠右的地方</p><p>** 子字符串查找。** 如果从 M-1 到 0 的所有 j，txt.charAt (i+j) 都和 pat.charAt (j) 相等，那么就找到了一个匹配。否则匹配失败，就会遇到以下三种情况。</p><ul><li>如果造成匹配失败的字符不包含在模式字符串中，将模式字符串向右移动 j+1 个位置 (即将 i 增加 j+1)。</li><li>如果造成匹配失败的字符包含在模式字符串中，那就可以使用 right [] 数组来将模式字符串和文本对齐，使得该字符和它在模式字符串中出现的最右位置相匹配。</li><li>如果这种方式无法增大 1, 那就直接将 i 加 1 来保证模式字符串至少向右移动了一个位置。</li></ul><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">BoyerMoore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">let</span> <span class="token constant">R</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">let</span> pattern <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">let</span> pat</pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token constant">R</span> <span class="token operator">=</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    pat <span class="token operator">=</span> p</pre></td></tr><tr><td data-num="9"></td><td><pre>    right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">R</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 初始化</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> c <span class="token operator">&lt;</span> <span class="token constant">R</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      right<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> pat<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token comment">// 记录每个字符最后出现的位置 </span></pre></td></tr><tr><td data-num="15"></td><td><pre>      right<span class="token punctuation">[</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> j</pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">let</span> m <span class="token operator">=</span> pat<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">let</span> n <span class="token operator">=</span> txt<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">let</span> skip</pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 从右边一整个一整个套着比对</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> i <span class="token operator">+=</span> skip<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      skip <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 遇到不匹配就跳过 skip 的值并退出当前循环</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pat<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>          skip <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> right<span class="token punctuation">[</span>txt<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>          <span class="token keyword">break</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>skip <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i <span class="token comment">// 找到</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">return</span> n <span class="token comment">// 没找到</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817225117047.png" alt="image-20220817225117047"></p><p>命题 O。在一般情况下，对于长度为 N 的文本和长度为 M 的模式字符串，使用了 Boyer-Moore 的子字符串查找算法通过启发式处理不匹配的字符需要～N/M 次字符比较。</p><h3 id="rabin-karp指纹字符串查找算法"><a class="anchor" href="#rabin-karp指纹字符串查找算法">#</a> Rabin-Karp 指纹字符串查找算法</h3><p>M.O.Rabin 和 R.A,Karp 发明了一种完全不同的基于散列的字符串查找算法。我们需要计算模式・字符串的散列函数，然后用相同的散列函数计算文本中所有可能的 M 个字符的子字符串散列值并寻找匹配。如果找到了一个散列值和模式字符串相同的子字符串，那么再继续验证两者是否匹配。这个过程等价于将模式保存在一张散列表中，然后在文本的所有子字符串中进行查找。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817225508101.png" alt="image-20220817225508101"></p><p>** 计算散列函数。** 这段代码计算了用 char 值数组表示的 R 进制的 M 位数的散列函数，所需时间与 M 成正比。(将 M 作为参数传递给该方法，这样就可以将它同时用于模式字符串和正文。) 对于这个数中的每一位数字，将散列值乘以 R，加上这个数字，除以 Q 并取其余数。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token comment">// 计算 key [0..M-1] 的散列值</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">long</span> h <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token class-name">M</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		h <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">R</span> <span class="token operator">*</span> h <span class="token operator">+</span> key<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token class-name">Q</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">return</span> h</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>关键思想。</strong></p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817225952864.png" alt="image-20220817225952864"></p><p>即将它减去第一个数字的值，乘以 R，再加上最后一个数字的值。现在，关键的一点在于不需要保存这些数的值，而只需要保存它们除以 Q 之后的余数。</p><p>子字符串查找算法的实现。构造函数为模式字符串计算了散列值 patHash 并在变量 RM 中保存了 R<sup> M-1</sup>mod Q 的值。Search () 方法开头计算了文本的前 M 个字母的散列值并将它和模式字符串的散列值进行比较。如果未能匹配，它将会在文本中继续前进，用以上讨论的方法计算由位置 i 开始的 M 个字符的散列值，将它保存在 txtHash 变量中并将每个新的散列值和 patHash 进行比较.</p><figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">function</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token parameter">pattern</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token constant">R</span> <span class="token operator">=</span> <span class="token number">256</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    m <span class="token operator">=</span> pattern<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="4"></td><td><pre>    q <span class="token operator">=</span> <span class="token number">997</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// precompute R^(m-1) % q for use in removing leading digit</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token constant">RM</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token constant">RM</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">R</span> <span class="token operator">*</span> <span class="token constant">RM</span><span class="token punctuation">)</span> <span class="token operator">%</span> q</pre></td></tr><tr><td data-num="9"></td><td><pre>    patHash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 返回模式字符串首次出现的索引</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">let</span> n <span class="token operator">=</span> txt<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> n</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">let</span> txtHash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>txt<span class="token punctuation">,</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 在偏移 0 中检查比赛</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>patHash <span class="token operator">==</span> txtHash<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 检查哈希匹配；如果哈希匹配，请检查确切的匹配</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>      <span class="token comment">// 删除前导数字，添加尾巴数，检查匹配项。</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      txtHash <span class="token operator">=</span> <span class="token punctuation">(</span>txtHash <span class="token operator">+</span> q <span class="token operator">-</span> <span class="token constant">RM</span> <span class="token operator">*</span> txt<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> m<span class="token punctuation">)</span> <span class="token operator">%</span> q<span class="token punctuation">)</span> <span class="token operator">%</span> q</pre></td></tr><tr><td data-num="22"></td><td><pre>      txtHash <span class="token operator">=</span> <span class="token punctuation">(</span>txtHash <span class="token operator">*</span> <span class="token constant">R</span> <span class="token operator">+</span> txt<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> q</pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token comment">// 匹配</span></pre></td></tr><tr><td data-num="24"></td><td><pre>      <span class="token keyword">let</span> offset <span class="token operator">=</span> i <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token keyword">if</span> <span class="token punctuation">(</span>patHash <span class="token operator">==</span> txtHash<span class="token punctuation">)</span> <span class="token keyword">return</span> offset</pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">return</span> n</pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817230356027.png" alt="image-20220817230356027"></p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817230423377.png" alt="image-20220817230423377"></p><p>命题 P。使用蒙特卡洛算法的 Rabin-Karp 子字符串查找算法的运行时间是线性级别的且出错的概率极小。使用拉斯维加斯算法的 Rabin-Karp 子字符串查找算法能够保证正确性且性能极其接近线性级别。</p><h3 id="总结"><a class="anchor" href="#总结">#</a> 总结</h3><p>它们都各有特点：暴力查找算法的实现非常简单且在一般的情况下都工作良好 (Java 的 String 类型的 indexOf () 方法使用的就是暴力子字符串查找算法)。Knuth-Morris-Pratt 算法能够保证线性级别的性能且不需要在正文中回退；Boyer-Moore 算法的性能在一般情况下都是亚线性级别 (可能是线性级别的 M 倍); Rabin-Karp 算法是线性级别。每种算法也各有缺点：暴力查找算法所需的时间可能和 MN 成正比；Knuth-Morris-Pratt 算法和 Boyer-Moore 算法都需要额外的内存空间；Rabin-Karp 算法的内循环很长（若干次算术运算，而其他算法都只需要比较字符)。这些特点都总结在了表 5.3.2 中。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220817230508145.png" alt="image-20220817230508145"></p><h2 id="54正则表达式regular-expressions"><a class="anchor" href="#54正则表达式regular-expressions">#</a> 5.4 正则表达式 (Regular Expressions)</h2><p>要处理正则表达式，就需要一种更加强大的抽象自动机。因为或操作的存在，自动机无法仅根・据一个字符就判断出模式是否出现；事实上，因为闭包的存在，自动机甚至无法知道需要检查多少。字符才会出现匹配失败。为了克服这些困难，<strong>我们需要非确定性的自动机</strong>.</p><h3 id="非确定性有限状态自动机nfa"><a class="anchor" href="#非确定性有限状态自动机nfa">#</a> 非确定性有限状态自动机 (NFA)</h3><ul><li>构造和给定正则表达式相对应的非确定有限状态自动机；</li><li>模拟 NFA 在给定文本上的运行轨迹。</li></ul><p>Kleene 定理是理论计算机科学中的一个重要结论，它证明了对于任意正则表达式都存在一个与之对应的非确定有限状态自动机（反之亦然）。</p><p>NFA 有以下特点：</p><ul><li>长度为 M 的正则表达式中的每个字符在所对应的 NFA 中都有且只有一个对应的状态。NFA 的起始状态为 0 并含有一个 (虚拟的) 接受状态 M。</li><li>字母表中的字符所对应的状态都有一条从它指出的边，这条边指向模式中的下一个字符所对应的状态（图中的黑色的边)。</li><li>元字符 “(” 和 “)” 和 “|” 和 “*” 所对应的状态至少含有一条指出的边 (图中的红色的边)，这些边可能指向其他的任意状态。</li><li>有些状态有多条指出的边，但一个状态只能有一条指出的黑色边。</li></ul><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220820133816906.png" alt="image-20220820133816906"></p><p>状态转换有以下两种方式：</p><ul><li>如果当前状态和字母表中的一个字符相对应且文本中的当前字符和该字符相匹配，自动机可以扫过文本中的该字符并（由黑色的边）转换到下一个状态。我们将这种转换称为匹配转换。</li><li>自动机可以通过红色的边转换到另一个状态而不扫描文本中的任何字符。我们将这种转换称为∈- 转换，也就是说它所对应的 “匹配” 是一个空字符串∈。(就是一些符号)</li></ul><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220820134000102.png" alt="image-20220820134000102"></p><p>图 5.4.3 的例子说明了即使对于类似于 AAAABD 这种 NFA 本应该能够识别的输入文本，也可以找到一个使 NFA 停滞的状态转换序列。例如，如果 NFA 选择在扫描完所有 A 之前就转换到状态 4，它就无法再继续前进了，因为离开状态 4 的唯一办法是匹配 B。这两个例子说明了这种自动机的不确定性。在扫描了一个 A 并到达状态 3 之后，NFA 面临着两个选择：它可以转换到状态 4, 或者回到状态 2。这次选择或者会使它最终达到接受状态（如第一个例子所示）或者进入停滞 (如第二个例子所示）。NFA 在状态 1 时也需要进行选择（是否由 E - 转换到达状态 2 或者状态 6)。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220820134415495.png" alt="image-20220820134415495"></p><h3 id="模拟nfa的运行"><a class="anchor" href="#模拟nfa的运行">#</a> 模拟 NFA 的运行</h3><p><strong>自动机的表示</strong>。首先，需要能够表示 NFA。选择很简单：正则表达式本身已经给出了所有状态名（0 到 M 之间的整数，其中 M 为正则表达式的长度)。用 char 数组 re [] 保存正则表达式本身，这个数组也表示了匹配的转换（如果 ire [i] 存在于字母表中，那么就存在一个从 i 到 i+1 的匹配转换)。∈- 转换最自然的表示方法当然是有向图 —— 它们都是连接 0 到 M 之间的各个顶点的有向边 (图 5.4.4 中的红色边）。. 因此，我们用有向图 G 表示所有∈- 转换。在讨论模拟的过程之后将讨论由给定正则表达式构建有向图的任务。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220820134720574.png" alt="image-20220820134720574"></p><p>命题 Q。判定一个长度为 M 的正则表达式所对应的 NFA 能否识别一段长度为 N 的文本所需的时间在最坏情况下和 MN 成正比。</p><h3 id="构造和正则相对于的nfa"><a class="anchor" href="#构造和正则相对于的nfa">#</a> 构造和正则相对于的 NFA</h3><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220820134849698.png" alt="image-20220820134849698"></p><pre><code>
</code></pre><p>命题 R。构造和长度为 M 的正则表达式相对应的 NFA 所需的时间和空间在最坏情况下与 M 成正比。</p><p><img data-src="%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B.assets/image-20220820135000721.png" alt="image-20220820135000721"></p><h2 id="55-数据压缩data-compression"><a class="anchor" href="#55-数据压缩data-compression">#</a> 5.5 数据压缩 (Data Compression)</h2><p>压缩数据的原因主要有两点：节省保存信息所需的空间和节省传输信息所需的时间。</p><p>任何数据压缩算法的效果都十分依赖于输入的特征。注意：本书中，我们在提到性能的时候一般指的都是时间；而对于数据压缩，性能指代的是算法的压缩率，当然也会考虑压缩的用时。</p><h3 id="游戏规则"><a class="anchor" href="#游戏规则">#</a> 游戏规则</h3><p>现代计算机系统中处理的所有类型的数据都有一个共同点：它们最终都是用二进制表示的。我们可以将它们都看成一串比特 (或者字节) 的序列。简单起见，本节中使用比特流这个术语表示比特的序列，用字节流这个术语表示可以看作固定大小的字节序列的比特序列。比特流或字节流可以是保存在计算机中的文件，也可以是互联网上传输的一条消息。</p><p>如果使用 | B | 表示比特流中比特的数量的话，我们感兴趣的是将 | C (B)| / |B | 最小化，这个值被称为压缩率。</p><p>这种模型叫做无损压缩模型 — 保证不丢失任何信息，即压缩和展开之后的比特流必须和原始的比特流完全相同。许多种类型的文件都会用到无损压缩，例如数值数据或者可执行的代码。对于某些类型的文件（例如图像、视频和音乐)，有损的压缩方法也是可以接受的，此时解码器所产生的输出只是与原输入文件近似。有损压缩算法的评价标准不仅是压缩率，还包括主观的质量感受。在本书中不会讨论有损压缩算法。</p><h3 id="读取二进制数据"><a class="anchor" href="#读取二进制数据">#</a> 读取二进制数据</h3></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-08-21 18:39:18" itemprop="dateModified" datetime="2022-08-21T18:39:18+08:00">2022-08-21</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sparkle 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sparkle 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="sparkle 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sparkle <i class="ic i-at"><em>@</em></i>Sparkle</li><li class="link"><strong>本文链接：</strong> <a href="https://1234cas.github.io/1234cas.github.io/Algorithms/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B/">https://1234cas.github.io/1234cas.github.io/Algorithms/算法第四版下/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Algorithms/%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E9%A2%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicliwyw55j20zk0m8hdt.jpg" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/Algorithms/%E5%89%91%E6%8C%87offer/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicliierfjj20zk0m8npd.jpg" title="未命名"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%9B%BEgraphs"><span class="toc-number">1.</span> <span class="toc-text">4. 图 (Graphs)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E6%97%A0%E5%90%91%E5%9B%BEundirected-graphs"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 无向图 (Undirected Graphs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.1.</span> <span class="toc-text">定义与术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">无向图数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2dfs"><span class="toc-number">1.1.3.</span> <span class="toc-text">深度优先搜索 (DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">寻找路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs"><span class="toc-number">1.1.5.</span> <span class="toc-text">广度优先搜索 (BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">连通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%9B%BE"><span class="toc-number">1.1.7.</span> <span class="toc-text">符号图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%9C%89%E5%90%91%E5%9B%BEdirected-graphs"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 有向图 (Directed Graphs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AF%E8%AF%AD-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义与术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">有向图数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">有向图的可达性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%92%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BEdag"><span class="toc-number">1.2.4.</span> <span class="toc-text">环和有向无环图 (DAG)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">有向图中的强连通性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91minimum-spanning-trees"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 最小生成树 (Minimum Spanning Trees)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">概念和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">加权无向图数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">Prim 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95-%E7%94%A8%E4%BA%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E7%9A%84-kruskal-%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">Kruskal 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84shortest-paths"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 最短路径 (Shortest Paths)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%BE%E5%BC%9B"><span class="toc-number">1.4.2.</span> <span class="toc-text">松弛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">Dijkstra 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8E%AF%E5%8A%A0%E6%9D%83%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.4.</span> <span class="toc-text">无环加权图中的最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.5.</span> <span class="toc-text">一般加权有向图中的最短路径问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2strings"><span class="toc-number">2.</span> <span class="toc-text">5. 字符串 (Strings)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8Fstring-sorts"><span class="toc-number">2.1.</span> <span class="toc-text">5.1 字符串排序 (String Sorts)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E8%A1%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">字母表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%B4%A2%E5%BC%95%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">键索引计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E4%BD%8D%E4%BC%98%E5%85%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8Flsd"><span class="toc-number">2.1.3.</span> <span class="toc-text">低位优先的字符串排序 (LSD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BD%8D%E4%BC%98%E5%85%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8Fmsd"><span class="toc-number">2.1.4.</span> <span class="toc-text">高位优先的字符串排序 (MSD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.1.5.</span> <span class="toc-text">三向字符串快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91tier"><span class="toc-number">2.2.</span> <span class="toc-text">5.2 单词查找树 (tier)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">单词查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%90%91%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">2.2.3.</span> <span class="toc-text">三向单词查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%90%91%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">三向单词查找树性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E5%93%AA%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">应该使用字符串符号表的哪种实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2substring-search"><span class="toc-number">2.3.</span> <span class="toc-text">5.3 子字符串搜索 (Substring Search)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">暴力子字符串查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#knuth-morris-pratt%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">Knuth-Morris-Pratt 子字符串查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boyer-moore%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">Boyer-Moore 字符串查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rabin-karp%E6%8C%87%E7%BA%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">Rabin-Karp 指纹字符串查找算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fregular-expressions"><span class="toc-number">2.4.</span> <span class="toc-text">5.4 正则表达式 (Regular Expressions)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BAnfa"><span class="toc-number">2.4.1.</span> <span class="toc-text">非确定性有限状态自动机 (NFA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9Fnfa%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">2.4.2.</span> <span class="toc-text">模拟 NFA 的运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%AD%A3%E5%88%99%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%9A%84nfa"><span class="toc-number">2.4.3.</span> <span class="toc-text">构造和正则相对于的 NFA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9data-compression"><span class="toc-number">2.5.</span> <span class="toc-text">5.5 数据压缩 (Data Compression)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99"><span class="toc-number">2.5.1.</span> <span class="toc-text">游戏规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">2.5.2.</span> <span class="toc-text">读取二进制数据</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sparkle" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sparkle</p><div class="description" itemprop="description">好好读书</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">35</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;instagram.com&#x2F;yourname"><i class="ic i-instagram"></i></span> <span class="exturl item skype" data-url="c2t5cGU6eW91cm5hbWU/Y2FsbHxjaGF0" title="skype:yourname?call|chat"><i class="ic i-skype"></i></span> <span class="exturl item douban" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveW91cm5hbWUv" title="https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yourname&#x2F;"><i class="ic i-douban"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Algorithms/%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B%E9%A2%98/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Algorithms/%E5%89%91%E6%8C%87offer/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/Front-end/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/Front-end/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Vue面试题">Vue面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/Hexo/Hexo/" title="Hexo">Hexo</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Algorithms/%E5%89%91%E6%8C%87offer/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Algorithms/%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E4%B8%8B/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E8%AE%B0/" title="分类于 日记">日记</a></div><span><a href="/Diary/2021-11-14/" title="2022-11-14.">2022-11-14.</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/Front-end/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/Front-end/Vue/vuex/" title="vuex">vuex</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E8%AE%B0/" title="分类于 日记">日记</a></div><span><a href="/Diary/2022-4-4/" title="2022-4-4">2022-4-4</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/Front-end/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/Front-end/Vue/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E7%AC%94%E8%AE%B0/" title="黑马头条笔记">黑马头条笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/Front-end/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/Front-end/ES6/ES6%E4%B8%8A/" title="ES6上">ES6上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Front-end/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/Front-end/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/Front-end/Vue/vue-router/" title="Vue router">Vue router</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sparkle @ Sparkle</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">681k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">10:20</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Algorithms/算法第四版下/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->