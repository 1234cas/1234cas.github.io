<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <div id="app" @click="add">黑马程序员</div>
    <script>

        var app = new Vue({
            el: "#app",
            data: {
                message: "黑马程序员",
                array: [],
                obj: {},
            },
            methods: {
                add(e) {
                    console.log(e);
                }

            }
        })
    </script>
    <h3>例</h3>
    <xmp>
        <div id="app">黑马程序员</div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    message: "黑马程序员",
                    array: [],
                    obj: {},
                },
                methods: {

                }
            })
        </script>
    </xmp>

    <h3>el</h3>
    <p>Vue实例的作用范围是什么呢?<br>
        vue会管理el选项命中的元素及其内部的后代元素
    </p>
    <p>
        是否可以使用其他的选择器?<br>
        可以使用其他的选择器,但是建议使用ID选择器
    </p>
    <p>
        是否可以设置其他的dom元素呢?<br>
        可以使用其他的双标签,不能使用HTML和BODY
    </p>

    <h3>data</h3>
    <p>Vue中用到的数据定义在data中</p>
    <p>data中可以写复杂类型的数据</p>
    <p>渲染复杂类型数据时,遵守js的语法即可</p>

    <h3>v-text</h3>
    <p>v-text指令的作用是:设置标签的内容(textContent)</p>
    <p>默认写法会替换全部内容,使用差值表达式{{}}可以替换指定内容</p>
    <p>内部支持写表达式</p>

    <h3>v-html</h3>
    <p>v-html指令的作用是:设置元素的innerHTML</p>
    <p>内容中有html结构会被解析为标签</p>
    <p>v-text指令无论内容是什么,只会解析为文本</p>
    <p>解析文本使用v-text,需要解析html结构使用v-html</p>

    <h3>v-on</h3>
    <p>v-on指令的作用是:为元素绑定事件</p>
    <p>事件名不需要写on</p>
    <p>指令可以简写为@</p>
    <p>绑定的方法定义在methods属性中</p>
    <p>方法内部通过this关键字可以访问定义在data中数据</p>

    <h3>加减</h3>
    <xmp>
        <div class="input-num" id="app">
            <button @click="sub">-</button>
            <span>{{num}}</span>
            <button v-on:click="add">+</button>
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    num: 1,
                },
                methods: {
                    add: function (num) {
                        this.num++;
                    },
                    sub: function (num) {
                        this.num--
                    },
                }
            })
        </script>
    </xmp>

    <h3>小总结</h3>
    <p>创建Vue示例时:el(挂载点),data(数据),methods(方法)</p>
    <p>v-on指令的作用是绑定事件,简写为@</p>
    <p>方法中通过this,关键字获取data中的数据</p>
    <p>v-text指令的作用是:设置元素的文本值,简写为{{}}</p>
    <p>v-html指令的作用是:设置元素的innerHTML</p>
    <hr>

    <h3>v-show</h3>
    <p>v-show指令的作用是:根据真假切换元素的显示状态</p>
    <p>原理是修改元素的display,实现显示隐藏</p>
    <p>指令后面的内容,最终都会解析为布尔值</p>
    <p>数据改变之后,对应元素的显示状态会同步更新</p>

    <h3>v-if</h3>
    <p>v-if指令的作用是:根据表达式的真假切换元素的显示状态</p>
    <p>本质是通过操纵dom元素来切换显示状态</p>
    <p>频繁的切换v-show,反之使用v-if,前者的切换消耗小</p>

    <h3>v-bind</h3>
    <p>v-bind指令的作用是:为元素绑定属性</p>
    <p>完整写法是v-bind:属性名=""</p>
    <p>简写的话可以直接省略v-bind,只保留:属性名</p>
    <p>需要动态的增删class建议使用对象的方式</p>

    <h3>图片切换</h3>
    <xmp>
        <div id="app">
            <a href="#" @click="prex" v-show="index!=0">上</a>
            <img :src="imgArr[index]" alt="">
            <a href="#" @click="next" v-show="index<=imgArr.length">下</a>
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    imgArr: [
                        "../images/1.jpg",
                        "../images/2.jpg",
                        "../images/3.jpg",
                        "../images/4.jpg",
                        "../images/5.jpg",
                    ],
                    index: 1,
                },
                methods: {
                    prex: function () {
                        this.index--;
                    },
                    next: function () {
                        this.index++;
                    },
                }
            })
        </script>
    </xmp>

    <h3>小总结</h3>
    <p>列表数据使用数组保存</p>
    <p>v-bind指令可以设置元素属性,比如src 写法：src=""</p>
    <p>v-show和v-if都可以切换元素的显示状态,频繁切换用v-show</p>
    <hr>

    <h3>v-for</h3>
    <xmp>
        <div id="app">
            <ul>
                <li v-for="item in arr" :title="item">{{item}}</li>
                <li v-for="(item,index) in object">{{item}}</li>
            </ul>
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    arr: [1, 2, 3, 4, 5],
                    object: {
                        name: "nihao",
                        name: "xiexie",
                    }
                },
            })
        </script>
    </xmp>
    <p>v-for指令的作用是:根据数据生成列表结构</p>
    <p>数组经常和v-for结合使用</p>
    <p>语法是( item,index ) in 数据</p>
    <p>item和index可以结合其他指令—起使用</p>
    <p>数组长度的更新会同步到页面上,是响应式的</p>

    <h3>v-on补充</h3>
    <xmp>
        <div id="app">
            <input type="button" @click="doIt(p1,p2)">
            <input type="text" @keyup.enter="sayHi">
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                methods: {
                    doIt: function (p1, p2) { },
                    sayHi: function () { },
                }
            })
        </script>
    </xmp>
    <p>事件绑定的方法写成函数调用的形式，可以传入自定义参数</p>
    <p>定义方法时需要定义形参来接收传入的实参</p>
    <p>事件的后面跟上.修饰符可以对事件进行限制</p>
    <p>.enter 可以限制触发的按键为回车</p>

    <h3>v-model</h3>
    <p>v-model指令的作用是便捷的设置和获取表单元素的值</p>
    <p>绑定的数据会和表单元素值相关联</p>
    <p>绑定的数据←→表单元素的值</p>

    <h3>记事本</h3>
    <xmp>
        iv id="app">
        <input v-model="inputValue" @keyup.enter="add" autofocus="autofocus" autocomplete="off" placeholder="请输入"
            type="text">
        <ul>
            <li v-for="(item,index) in list">
                <div>
                    <span>{{index+1}}</span>
                    <label for="">{{item}}</label>
                    <button @click="remove(index)"></button>
                </div>
            </li>
        </ul>
        <footer v-show="list.length!=0">
            <span v-if="list.length!=0">
                <strong>{{list.length}}</strong>items list
            </span>
            <button v-if="list.length!=0" @click="clear"></button>
        </footer>
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    list: ["coding", "english", "exercise"],
                    inputValue: "好好学习，天天向上",
                },
                methods: {
                    add: function () {
                        this.list.push(this.inputValue);
                    },
                    remove: function (index) {
                        this.list.splice(index, 1);
                    },
                    clear: function () {
                        this.list = [];
                    }
                }
            })
        </script>
    </xmp>

    <h3>小总结</h3>
    <p>列表结构可以通过v-for指令结合数据生成</p>
    <p>v-on结合事件修饰符可以对事件进行限制,比如.enter</p>
    <p>v-on在绑定事件时可以传递自定义参数</p>
    <p>通过v-model可以快速的设置和获取表单元素的值</p>
    <p>基于数据的开发方式</p>
    <hr>

    <h3>axios</h3>
    <xmp>
        <script src="https: //unpkg.com/axios/dist/axios.min.js"></script>
        <script>
            axios.get(地址 ? key = value & key2 : value2).then(function (response) { }, function (err) { })
            axios.post(地址, { key: value, key2: value2 }).then(function (response) { }, function (err) { })
        </script>
    </xmp>
    <p>axios必须先导入才可以使用</p>
    <p>使用get或post方法即可发送对应的请求</p>
    <p>then方法中的回调函数会在请求成功或失败时触发</p>
    <p>通过回调函数的形参可以获取响应内容,或错误信息</p>
    <p>文档传送门 https://github.com/axios/axios</p>

    <h3>笑话</h3>
    <xmp>
        <div id="app">
            <li>{{joke}}</li>
            <button @click="getJoke"></button>
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    joke: "笑话",
                },
                methods: {
                    getJoke: function () {
                        var that = this;
                        axios.get("https://autumnfish.cn/api/joke").then(function (response) {
                            that.joke = response.data;
                        }, function (err) { });
                    },

                }
            })
        </script>
    </xmp>

    <h3>小总结</h3>
    <p>axios回调函数中的this已经改变,无法访问到data中数据</p>
    <p>把this保存起来,回调函数中直接使用保存的this即可</p>
    <p>和本地应用的最大区别就是改变了数据来源</p>

    <h3>天知道</h3>
    <xmp>
        <div id="app">
            <input type="text" @keyup.enter="getWeather" v-model="city">
            <ul>
                <!-- <li @click="clickSearch('北京')">北京</li>
                              <li @click="clickSearch('上海')">上海</li>
                              <li @click="clickSearch('广州')">广州</li>
                              <li @click="clickSearch('深圳')">深圳</li> -->
                <li v-for="city in hotCitys" @click="clickSearch(city)">{{city}}</li>
            </ul>
            <ul v-for="(item,index) in arr" :key="item.date" :style="{transitionDelay:index*100+'ms'}">
                <!-- :key和:style不知道干什么的 -->
                <li>{{item.date}}</li>
                <li>{{item.low}}</li>
                <li>{{item.high}}</li>
                <li>{{item.fengxiang}}</li>
                <li>{{item.type}}</li>
            </ul>
        </div>
        <script>
            var app = new Vue({
                el: "#app",
                data: {
                    arr: [],
                    city: "莆田",
                    hotCitys: ["上海", "深圳", "厦门", "莆田"],
                },
                methods: {
                    getWeather: function () {
                        var city = city;
                        var that = this;
                        axios.get("http://wthrcdn.etouch.cn/weather_mini?city=" + this.city)
                            .then(function (response) {
                                that.arr = response.data.data.forecast;
                            }, function (err) { })
                    },
                    // 高级写法？
                    // getWeather() {
                    //     this.arr = [];
                    //     axios
                    //         .get(`http://wthrcdn.etouch.cn/weather_mini?city=${this.city}`)
                    //         .then(res => {
                    //             this.arr = res.data.data.forecast;
                    //         })
                    //         .catch(err => {
                    //             console.log(err);
                    //         })
                    //         .finally(() => { });
                    // },
                    clickSearch(city) {
                        this.city = city;
                        this.getWeather();
                    }
                }
            })
        </script>
    </xmp>

    <h3>小总结</h3>
    <p>应用的逻辑代码建议和页面分离，使用单独的js文件编写</p>
    <p>axios回调函数中this指向改变了，需要额外的保存一份</p>
    <p>服务器返回的数据比较复杂时，获取的时候需要注意层级结构</p>
    <p>自定义参数可以让代码的复用性更高 </p>
    <p>methods中定义的方法内部，可以通过this关键字点出其他的方法</p>
    <hr>

    <h3><a href="demo/musicplayer.html">音乐播放器</a></h3>
    <p>不同的接口需要的数据是不同的，文档的阅读需要仔细</p>
    <p>页面结构复杂之后，通过审查元素的方式去快速定位相关元素</p>
    <p>响应式的数据都需要定义在data中定义</p>

    <h3>小tip</h3>
    <p>回调函数要用that来保存this</p>
    <p>splic是e数组删除的方法</p>



</body>

</html>